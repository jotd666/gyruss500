		.global osd_read_high_scores
		.global osd_write_high_scores
		.global	load_highscores
		.global	save_highscores
		.global osd_sound_start
		.global osd_music_stop
		.global music_tick
		.global	get_enabled_interrupts_value


* sound engine and also highscore management, common to all versions
	
.include "lvo/dos_lvos.i"
.include "gyruss.inc"
.include "sounds.inc"
.include "mixer.inc"

SCORE_FILE_SIZE = 0xB0-0x88

.macro	GET_RAM_START_IN_A6	
	.ifdef	RELEASE
	lea		z80_ram_buffer,a6
	.else
	move.l		z80_ram_start_8000,a6
	.endif
	.endm
	
osd_read_high_scores:
	movem.l	d0-d7/a0-a6,-(a7)
	GET_RAM_START_IN_A6
	lea		high_score_table_9488(a6),a5	
	move.l	_resload,d0
	beq.b	0f
	move.l	d0,a2
	bsr		get_hiscore_name
 	jsr		resload_GetFileSize(a2)		
	tst.l	d0
	jeq	1f
	bsr		get_hiscore_name
	move.l	a5,a1
	jsr		resload_LoadFile(a2)	
	bra.b	2f
0:
	tst.b	highscore_loaded
	jeq		1f
	lea		high_score_buffer(pc),a1
	lea		high_score_table_9488(a6),a0	
	move.w	#SCORE_FILE_SIZE-1,d0
0:
	move.b	(a1)+,(a0)+
	dbf		d0,0b
2:
	* also propagate the highest score to the
	* high score (separate memory locations as often)

	lea		high_score_table_9488+1(a6),a0	
	lea		highscore_last_digit_940D-2(a6),a1
	move.b	(a0)+,(a1)+
	move.b	(a0)+,(a1)+
	move.b	(a0)+,(a1)+
1:
	movem.l	(a7)+,d0-d7/a0-a6
	rts
	
osd_write_high_scores:
	movem.l	d0-d7/a0-a6,-(a7)
	.ifdef	RELEASE
	tst.b	cheat_used		| don't save score if cheat on
	bne.b	1f
	.endif
	GET_RAM_START_IN_A6

	lea		high_score_buffer(pc),a1
	lea		high_score_table_9488(a6),a0	
	move.w	#SCORE_FILE_SIZE-1,d0
0:
	move.b	(a0)+,(a1)+
	dbf		d0,0b

	st.b	highscore_needs_saving
	
	move.l	_resload,d0
	beq.b	1f
	move.l	d0,a2
	move.l	#SCORE_FILE_SIZE,d0
	lea		high_score_buffer(pc),a1
	bsr		get_hiscore_name
	jsr		resload_SaveFile(a2)
1:

	movem.l	(a7)+,d0-d7/a0-a6
	rts

	
get_hiscore_name:
    lea normal_hiscorename,a0
	rts
	
load_highscores:
	bsr.b		get_hiscore_name
    move.l  _resload,d0
    bne.b   1f

    move.l  _dosbase,a6
    move.l  a0,d1
    move.l  #1005,d2
    jsr     (_LVOOpen,a6)
    move.l  d0,d1
    beq.b   1f
    move.l  d1,d4
    move.l  #SCORE_FILE_SIZE,d3
    move.l  #high_score_buffer,d2
    jsr (_LVORead,a6)
    move.l  d4,d1
    jsr (_LVOClose,a6)   
	st.b	highscore_loaded
1:

    rts

save_highscores:
	tst.l	_resload
	bne.b	1f
    tst.b   highscore_needs_saving
    beq.b   1f
    move.l  _dosbase,a6
	bsr.b		get_hiscore_name
    move.l  a0,d1
    move.l  #1006,d2
    jsr     (_LVOOpen,a6)
    move.l  d0,d1
    beq.b   1f
    move.l  d1,d4
    move.l  #SCORE_FILE_SIZE,d3
    move.l  #high_score_buffer,d2
    jsr (_LVOWrite,a6)
    move.l  d4,d1
    jsr (_LVOClose,a6)   
1:	
    rts
    

osd_sound_stop:
	movem.l	d0/a0/a6,-(a7)
	move.w	#DMAF_AUD3,d0
	jbsr	MixerStopFX
	
	movem.l	(a7)+,d0/a0/a6
	* no RTS!!
osd_music_stop:
	movem.l	d0/a0/a6,-(a7)
	
 	lea		_custom,a6
	clr.b	music_playing
    jsr		_mt_end
    clr.w   music_tick   | not playing anymore
	move.b	#-1,music_track_start_number
	movem.l	(a7)+,d0/a0/a6
	rts
	
get_enabled_interrupts_value:	
	move.w	#0xC038+0x780,d0
	rts
	
* tunes sounds are: sound index followed by 0x15,0x16,0x17 (that we ignore!)
osd_sound_start:
	movem.l	d0/d1/a0/a6,-(a7)
	
	and.w	#0xFF,d0
	jne		0f
	* null sound: stop
	*jbsr	osd_sound_stop
	jra		10f
0:
	* original sound stop commands have bit 7 set. But if we follow them, they'll kill the

	cmp.b	#0x80,d0
	jcc		10f		| above 0x80 => forget it
	
	lsl.w	#3,d0
	lea		sound_table,a0
	add.w	d0,a0
	move.w	(a0),d1	| sound type
	beq.b	11f		| no sound, but not expected!
	cmp.w	#3,d1
	jeq		10f
2:
	cmp.w	#1,d1
	bne.b	4f		| music module
	moveq	#DMAF_AUD3,d0									
	move.l	(4,a0),a0
	jbsr		MixerPlayFX	
10:

	movem.l	(a7)+,d0/d1/a0/a6
	rts
11:
	move.w	d0,d1
	lsr.w	#3,d1
	BREAKPOINT	"unknown sound played in D1"
	jra		10b 
	
	* music
4:
	* don't play if already playing
	* (music_tick value is not important for looped tunes
	* as long as it's not zero)


	* here we allow music to override another looping music
	*tst.w	music_tick
	*bne.b	10b
	* play the proper module pattern
	* load up the countdown if loop
	
	move.w	(2,a0),d1	| pattern number in .mod file
	* since it's not zero, next vbl tick will play the music
	
	cmp.b	music_track_start_number(pc),d1
	beq.b	10b		| same track, skip

    movem.l d0-a6,-(a7)
	bsr		osd_music_stop
    lea _custom,a6
 	movem.l	d0/a0,-(a7)
	lea	gyruss_tunes,a0
	
	move.b	d1,music_track_start_number
	move.w	d1,d0	
    sub.l   a1,a1		| samples are in the module
    jsr _mt_init
	moveq	#7,d0		| only 3 first channels enabled for pt player
	jbsr	_mt_channelmask
	movem.l	(a7)+,d0/a0

    * set master volume a little less loud if needed
	move.b	(6,a0),music_volume
	move.b	(7,a0),music_loops
	move.w	(2,a0),music_pattern	| pattern number in .mod file
	move.w	(4,a0),d2

	move.w	d2,music_duration
	move.w	d2,music_tick

    moveq	#0,d0
	move.b	music_volume(pc),d0
    jsr	_mt_mastervol
	st.b	music_playing
    jsr _mt_start
    movem.l (a7)+,d0-a6
	
6:
	jra	10b

	

	
music_playing:
	.byte	0
looped_sound_enabled:
	.byte	0
music_loops:
	.byte	0
music_volume:
	.byte	0
music_track_start_number:
	.word	-1
music_pattern:
	.word	0
music_tick:
	.word	0

music_duration:
	.word	0
high_score_buffer:
	.skip	SCORE_FILE_SIZE
highscore_needs_saving:
	.byte	0
highscore_loaded:
	.byte	0

normal_hiscorename:
	.asciz	"gyruss.high"


