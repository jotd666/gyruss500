****************************************************************************
*
* Gyruss 68k port by JOTD
* 6809 sub cpu code
*
* Reverse engineering & conversion 2025 by JOTD
*
****************************************************************************

	.include "gyruss.inc"
	.include "gyruss_sub.inc"


	* to trace at some virtual PCs, insert this macro
	
	.ifndef	RELEASE
	.macro	ENABLE_REGS_LOG
	moveq	#1,d6
	moveq	#1,d7
	jbsr	osd_cpu_logging_control	
	.endm
	.macro	DISABLE_REGS_LOG
	moveq	#1,d6
	moveq	#0,d7
	jbsr	osd_cpu_logging_control	
	.endm
	
	.macro	LOG_REGS	m6809pc
	move.w	sr,-(a7)
	move.w	#0x\m6809pc,-(a7)
	move.w	#1,-(a7)   | subcpu
	jbsr	osd_log_cpu
	addq.w	#4,a7
	move.w	(a7)+,sr
	.endm
	.endif
	
	.macro	MOVE_W_D4_IN_A0
	rol.w	#8,d4
	move.b	d4,(a0)
	rol.w	#8,d4
	move.b	d4,(1,a0)
	.endm
	
	.macro	MOVE_W_D4_IN_A0_PLUS_1
	rol.w	#8,d4
	move.b	d4,(a0)+
	rol.w	#8,d4
	move.b	d4,(a0)
	.endm
	
	.macro	MOVE_W_A0_IN_D4
	move.b	(a0),d4
	rol.w	#8,d4
	move.b	(1,a0),d4
	.endm
	
* this code is mainly used to convert Z80-handled coordinates to polar
* displayable coordinates for enemy ships (not all sprites are concerned)
*
*	map(0x0000, 0x0000).r(FUNC(gyruss_state::scanline_r));
*	map(0x2000, 0x2000).w(FUNC(gyruss_state::slave_irq_mask_w)).nopr();
*	map(0x4000, 0x403f).ram();
*	map(0x4040, 0x40ff).ram().w(FUNC(gyruss_state::spriteram_w)).share(m_spriteram);
*	map(0x4100, 0x47ff).ram();
*	map(0x6000, 0x67ff).ram().share("main_cpus");
*	map(rom_start_e000, 0xffff).rom();
*
*   to set a breakpoint: bpset $F00F:sub

* offsets original values are keps because 6809 converter
* uses a translation get_6809_address routine

sprite_ram_4040 = 0x4040

* mapped to A000 on the other CPU, so everything RAM over A000 on the other
* cpu is visible by this CPU
shared_memory_6000 = 0x6000
frame_odd_or_even_6700 = 0x6700
draw_queued_sprites_flag_6701 = 0x6701
queue_sprites_flag_6702 = 0x6702
beamy_value_6710 = 0x6710    | just written to, no read by any cpu
update_sequence_control_flag_67fc = 0x67fc
update_sequence_control_flag_67fd = 0x67fd
sprite_index_pointer_4200 = 0x4200
pointer_4211 = 0x4211


* page 42 offsets for work variables
sprite_index_pointer_4200_lsb_01 = 0x01
number_of_sprites_to_update_09 = 0x09
number_of_sprites_to_update_total_0a = 0x0a
unknown_0b = 0x0b

* tell 6809 to perform more or less operations:
* 0xFF: don't do anything (state not reached in the game)
* 0x00: just sync the first sprites between 6000 and 4040. Earth
* from title appears if we do that, but not the stars (as they probably
* aren't coord-changed)
* 0x01: do the full sync & coord transformation (stars appear)
* as soon as title screen starts and never changes it
* it may write to that flag at times but always with 1
*
* the 68k port obviously cannot run both codes in parallel, nor we
* want to emulate a multiprocessing system with interrupts & switching
* so the code is simplified:
* - no irq
* - removed all "semaphore" sync variables
* - draw command called from Z80 code
* - queue command called from Z80 code

sprite_sync_status_67ff = 0x67ff

	.global	gyruss_sub_reset
	.global	gyruss_sub_draw
	.global	gyruss_sub_queue
	
set_irq_flag_2000:
	move.b	d0,m6809_interrupts_on
	rts
	
init_current_ybeam:
	move.b	#31,current_y_beam
	rts
	
next_current_ybeam:
	add.b	#14,current_y_beam
	rts
	
	.macro	GET_CURRENT_YBEAM
	move.b	current_y_beam,d0
	.endm
	
gyruss_sub_reset:
	jbsr	gyruss_sub_cpu_init
	moveq	#0,d0
	jbsr	set_irq_flag_2000              	| [$f000: clr    irq_flag_2000] disable interrupts
	                         	          | [...]
	move.b	#0x00,d0                        	| [$f003: ldd    #$0000] active wait
	move.w	#0x0000,d1                        	| [$f003: ldd    #$0000] active wait
	GET_ADDRESS	0x67f5                     	| [$f006: sta    $67f5]
	move.b	d0,(a0)                         	| [...]
	* we completely skip the code there. It contains some
	* cpu delay then some
	* code which is called when?? (there is no service mode in the game)
	

	              	| [$f095: clr    irq_flag_2000] clear interrupts (again)
	                         	| [...]
* clear sprite ram
	move.w	#sprite_ram_4040,d4             	| [$f098: ldu    #sprite_ram_4040]
	moveq	#0,d2
	move.w	#0x0400-0x20,d2         | [$f09b: ldx    #$0400] do not overshoot!
	moveq	#0,d1
	* could be optimized but this is some init routine...
l_f09e:
	GET_U_ADDRESS	0                        	| [$f09e: std    ,u++]
	addq.w	#2,d4
	move.w	d1,(a0)                	| [...]
	subq.w	#0x1,d2                         	| [$f0a0: leax   -$1,x]
	jne	l_f09e                             	| [$f0a2: bne    $f09e]
	move.b	#0x42,d0                        	| [$f0a4: lda    #$42]
	SET_DP_FROM_A                          	| [$f0a6: tfr    a,dp]

								| [$f0a8: clr    irq_flag_2000]
* enable interrupts
	move.b	#0x01,d0                        	| [$f0b1: lda    #$01]
	jbsr	set_irq_flag_2000              	| [$f0b3: sta    irq_flag_2000]
	* return to caller (initializer) instead of infinite loop
    rts
                               	| [$f0b6: bra    $f0b6]

			
			
			
			
			
			
					| [$f0b8: clr    irq_flag_2000] ack IRQ
			
			
			                     	| [$f0bb: lda    $67ff]
					| [...]
										| [$f0c6: lbeq   $f54a]
					| [$f0be: inca]
									| [$f0bf: lbeq   $f15f]
					| [$f0c3: lda    $67ff]
			
* sub draw just copies the 48 selected sprites for that frame
* into the 0x4040 hardware buffer (length: 0xC0)	
											| [...]
gyruss_sub_draw:
	jbsr	gyruss_sub_cpu_init
							| [$f0ca: lda    $6701]
l_f0ca:
	                        	| [...]
	                           	| [$f0cd: beq    $f0ca]


	GET_ADDRESS	frame_odd_or_even_6700	| [$f0cf: lda    frame_odd_or_even_6700]
	tst.b	(a0)                         	| [...]
	jne	frame_odd_f1a3                             	| [$f0d2: lbne   $f1a3]
	* frame even

	jbsr	try_to_update_all_sprites_even_f4e4      	| [$f0d6: jsr    $f4e4]
	
	GET_ADDRESS	0x6400                     	| [$f0d9: clr    $6400]
	move.b	#0,(a0)                         	| [...]
	clr.b	(0x40,a0)                     	| [$f0dc: clr    $6440]
	clr.b	(0x80,a0)                     	| [$f0df: clr    $6480]
	clr.b	(0xC0,a0)                     	| [$f0e2: clr    $64c0]
	move.w	#shared_memory_6000,d4          	| [$f0e5: ldu    #shared_memory_6000]
	GET_DP_ADDRESS	0x0f                    	| [$f0e8: stu    $0f]
	MOVE_W_D4_IN_A0                         	| [...]
	move.w	#0x6400,d4                      	| [$f0ea: ldu    #$6400]
	addq.w	#2,a0	                    	| [$f0ed: stu    $11]
	MOVE_W_D4_IN_A0                         	| [...]
	rts

gyruss_sub_queue:
	jbsr	gyruss_sub_cpu_init
	
	GET_ADDRESS	frame_odd_or_even_6700
	tst.b	(a0)
	jne		sub_queue_odd	

sub_queue_even:
	
l_f0ef:
															| [$f0ef: lda    $6702]
											| [...]
											| [$f0f2: beq    $f0ef]
	GET_ADDRESS	update_sequence_control_flag_67fd                     	| [$f0f4: lda    $67fd]
	move.b	(a0),d0                         	| [...]
	bne	alternate_update_sequence_f165          	| [$f0f7: bne    $f165]



	jbsr	ship_coordinate_transform_f566          | [$f0f9: jsr    $f566]
	* here beamy = 31 on the arcade machine
	jbsr	init_current_ybeam
	jbsr	update_multiplexed_sprites_f6ee           | [$f0fc: jsr    $f6ee]
	jbsr	enemies_coordinate_transform_f626        	| [$f0ff: jsr    $f626]
	jbsr	update_multiplexed_sprites_f6ee           | [$f102: jsr    $f6ee]
	jbsr	enemies_coordinate_transform_f589        	| [$f105: jsr    $f589]
	jbsr	update_multiplexed_sprites_f6ee           | [$f108: jsr    $f6ee]
	jbsr	coordinate_transform_one_f5e7           | [$f10b: jsr    $f5e7]
	jbsr	update_multiplexed_sprites_f6ee           | [$f10e: jsr    $f6ee]
	jbsr	coordinate_transform_two_f5f3           | [$f111: jsr    $f5f3]
	jbsr	update_multiplexed_sprites_f6ee           | [$f114: jsr    $f6ee]
	jbsr	coordinate_transform_three_f5ff         | [$f117: jsr    $f5ff]
	jbsr	update_multiplexed_sprites_f6ee           | [$f11a: jsr    $f6ee]
	jbsr	coordinate_transform_four_f60b          | [$f11d: jsr    $f60b]
	jbsr	update_multiplexed_sprites_f6ee           | [$f120: jsr    $f6ee]
	jbsr	coordinate_transform_eight_f617         | [$f123: jsr    $f617]  different from other update sequence
	jbsr	update_multiplexed_sprites_f6ee           | [$f126: jsr    $f6ee]
	jbsr	coordinate_transform_six_f636           | [$f129: jsr    $f636]
	jbsr	update_multiplexed_sprites_f6ee           | [$f12c: jsr    $f6ee]
	jbsr	coordinate_transform_seven_f645         | [$f12f: jsr    $f645]
	jbsr	update_multiplexed_sprites_f6ee           | [$f132: jsr    $f6ee]


	
	* here beamy = 164 on the arcade machine
continue_f135:
	move.b	#0x29,d0                        	| [$f135: lda    #$29]
	move.b	#0x17,d1                        	| [$f137: ldb    #$17]
	GET_ADDRESS	0x6400                     	| [$f139: cmpb   $6400]
	cmp.b	(a0),d1                          	| [...]
	jcc	l_f141                             	| [$f13c: jcc    $f141]
											| [$f13e: stb    $6400] [uncovered]
	move.b	d1,(a0)                         	| [...]
l_f141:
	GET_ADDRESS	0x6440                     	| [$f141: cmpa   $6440]
	cmp.b	(a0),d0                          	| [...]
	jcc	l_f149                             	| [$f144: jcc    $f149]
	                     	| [$f146: sta    $6440] [uncovered]
	move.b	d0,(a0)                         	| [...]
l_f149:
	GET_ADDRESS	0x6480                     	| [$f149: cmpa   $6480]
	cmp.b	(a0),d0                          	| [...]
	jcc	l_f151                             	| [$f14c: jcc    $f151]
	                     	| [$f14e: sta    $6480] [uncovered]
	move.b	d0,(a0)                         	| [...]
l_f151:
	GET_ADDRESS	0x64c0                     	| [$f151: cmpb   $64c0]
	cmp.b	(a0),d1                          	| [...]
	jcc	l_f159                             	| [$f154: jcc    $f159]
	                     	| [$f156: stb    $64c0] [uncovered]
	move.b	d1,(a0)                         	| [...]
l_f159:
	                     	| [$f159: lda    >$0000]
*	move.b	#0x29,d0                         	| [...]
* at this point, A = $29, everytime! but no need to write it, as it's not
* used by any cpu
*	GET_ADDRESS	beamy_value_6710                     	| [$f15c: sta    $6710]
*	move.b	d0,(a0)                         	| [...]
get_out_immediately_f15f:
	move.b	#0x01,d0                        	| [$f15f: lda    #$01]
	jbsr	set_irq_flag_2000              	| [$f161: sta    irq_flag_2000] enable interrupts
	rts       	| [$f164: rti]

alternate_update_sequence_f165:
	jbsr	ship_coordinate_transform_f566                            	| [$f165: jsr    $f566]
	jbsr	update_multiplexed_sprites_f6ee                            	| [$f168: jsr    $f6ee]
	jbsr	coordinate_transform_zero_f660                            	| [$f16b: jsr    $f660]
	jbsr	update_multiplexed_sprites_f6ee                            	| [$f16e: jsr    $f6ee]
	jbsr	enemies_coordinate_transform_f589                            	| [$f171: jsr    $f589]
	jbsr	update_multiplexed_sprites_f6ee                            	| [$f174: jsr    $f6ee]
	jbsr	coordinate_transform_one_f5e7                            	| [$f177: jsr    $f5e7]
	jbsr	update_multiplexed_sprites_f6ee                            	| [$f17a: jsr    $f6ee]
	jbsr	coordinate_transform_two_f5f3                            	| [$f17d: jsr    $f5f3]
	jbsr	update_multiplexed_sprites_f6ee                            	| [$f180: jsr    $f6ee]
	jbsr	coordinate_transform_three_f5ff                            	| [$f183: jsr    $f5ff]
	jbsr	update_multiplexed_sprites_f6ee                            	| [$f186: jsr    $f6ee]
	jbsr	coordinate_transform_four_f60b                            	| [$f189: jsr    $f60b]
	jbsr	update_multiplexed_sprites_f6ee                            	| [$f18c: jsr    $f6ee]
	jbsr	coordinate_transform_five_f651                            	| [$f18f: jsr    $f651]
	jbsr	update_multiplexed_sprites_f6ee                            	| [$f192: jsr    $f6ee]
	jbsr	coordinate_transform_six_f636                            	| [$f195: jsr    $f636]
	jbsr	update_multiplexed_sprites_f6ee                            	| [$f198: jsr    $f6ee]
	jbsr	coordinate_transform_seven_f645                            	| [$f19b: jsr    $f645]
	jbsr	update_multiplexed_sprites_f6ee                            	| [$f19e: jsr    $f6ee]
	bra	continue_f135                             	| [$f1a1: bra    $f135]

frame_odd_f1a3:
	jbsr	try_to_update_all_sprites_odd_f48b        	| [$f1a3: jsr    $f48b]
	GET_ADDRESS	0x6500                     	| [$f1a6: clr    $6500]
	clr.b	(a0)                         	| [...]
	clr.b	(0x40,a0)                     	| [$f1a9: clr    $6540]
	clr.b	(0x80,a0)                     	| [$f1ac: clr    $6580]
	clr.b	(0xc0,a0)                     	| [$f1af: clr    $65c0]
	move.w	#0x6200,d4                      	| [$f1b2: ldu    #$6200]
	GET_DP_ADDRESS	0x0f                    	| [$f1b5: stu    $0f]
	MOVE_W_D4_IN_A0                         	| [...]
	move.w	#0x6500,d4                      	| [$f1b7: ldu    #$6500]
	GET_DP_ADDRESS	0x11                    	| [$f1ba: stu    $11]
	MOVE_W_D4_IN_A0                         	| [...]
	rts
	
sub_queue_odd:
	
l_f1bc:
											| [$f1bc: lda    $6702]
							| [...]
							| [$f1bf: beq    $f1bc]
	* if non-zero, seems that enemy shots are not moving
	GET_ADDRESS	update_sequence_control_flag_67fd                     	| [$f1c1: lda    $67fd]
	move.b	(a0),d0                         	| [...]
	bne	l_f232                             	| [$f1c4: bne    $f232]
	* the game performs calculations and tries to update
	* the maximum of sprites, checking the Y beam to see
	* if sprite slot can be reused (sprite multiplexing)
	* to avoid flashes. If we skip the "race_beam_update_sprites_xxxx"
	* routines, game still runs and animates, only it flashes more
	*
	* each non "race" routine does something to convert coords
	*
	* this is not possible to recreate faithfully specially
	* on amiga, where sprite multiplexing is done differently
	*
	* Fortunately, the enemies don't rely a lot on this and
	* have priority on the stars, so multplexing occurs only
	* when there are stars. Removing stars generation 
	* from the Z80 code fixes the annoying flashing issues
	* I was investigating for a (long) while. The code is 100%
	* correct, it's just that it cannot be done that way.
	jbsr	ship_coordinate_transform_f566                            	| [$f1c6: jsr    $f566]
	* here beamy = 31 on the arcade machine
	jbsr	init_current_ybeam
	jbsr	update_multiplexed_sprites_f695                            	| [$f1c9: jsr    $f695]
	* also used for player radial shots
	jbsr	enemies_coordinate_transform_f626                            	| [$f1cc: jsr    $f626]
	jbsr	update_multiplexed_sprites_f695                            	| [$f1cf: jsr    $f695]
	jbsr	enemies_coordinate_transform_f589                            	| [$f1d2: jsr    $f589]
	jbsr	update_multiplexed_sprites_f695                            	| [$f1d5: jsr    $f695]
	jbsr	coordinate_transform_one_f5e7                            	| [$f1d8: jsr    $f5e7]
	jbsr	update_multiplexed_sprites_f695                            	| [$f1db: jsr    $f695]
	jbsr	coordinate_transform_two_f5f3                            	| [$f1de: jsr    $f5f3]
	jbsr	update_multiplexed_sprites_f695                            	| [$f1e1: jsr    $f695]
	jbsr	coordinate_transform_three_f5ff                            	| [$f1e4: jsr    $f5ff]
	jbsr	update_multiplexed_sprites_f695                            	| [$f1e7: jsr    $f695]
	jbsr	coordinate_transform_four_f60b                            	| [$f1ea: jsr    $f60b]
	jbsr	update_multiplexed_sprites_f695                            	| [$f1ed: jsr    $f695]
	jbsr	coordinate_transform_eight_f617                            	| [$f1f0: jsr    $f617]
	jbsr	update_multiplexed_sprites_f695                            	| [$f1f3: jsr    $f695]
	jbsr	coordinate_transform_six_f636                            	| [$f1f6: jsr    $f636]
	jbsr	update_multiplexed_sprites_f695                            	| [$f1f9: jsr    $f695]
	jbsr	coordinate_transform_seven_f645                            	| [$f1fc: jsr    $f645]
	* here beamy = 169 on the arcade machine
	jbsr	update_multiplexed_sprites_f695                            	| [$f1ff: jsr    $f695]
	* here beamy = 176 on the arcade machine
continue_f202:
	move.b	#0x29,d0                        	| [$f202: lda    #$29]
	move.b	#0x17,d1                        	| [$f204: ldb    #$17]
	GET_ADDRESS	0x6500                     	| [$f206: cmpb   $6500]
	cmp.b	(a0),d1                          	| [...]
	jcc	l_f20e                             	| [$f209: jcc    $f20e]
											| [$f20b: stb    $6500] [uncovered]
	move.b	d1,(a0)                         	| [...]
l_f20e:
	GET_ADDRESS	0x6540                     	| [$f20e: cmpa   $6540]
	cmp.b	(a0),d0                          	| [...]
	jcc	l_f216                             	| [$f211: jcc    $f216]
											| [$f213: sta    $6540] [uncovered]
	move.b	d0,(a0)                         	| [...]
l_f216:
	GET_ADDRESS	0x6580                     	| [$f216: cmpa   $6580]
	cmp.b	(a0),d0                          	| [...]
	jcc	l_f21e                             	| [$f219: jcc    $f21e]
											| [$f21b: sta    $6580] [uncovered]
	move.b	d0,(a0)                         	| [...]
l_f21e:
	GET_ADDRESS	0x65c0                     	| [$f21e: cmpb   $65c0]
	cmp.b	(a0),d1                          	| [...]
	jcc	l_f226                             	| [$f221: jcc    $f226]
											| [$f223: stb    $65c0] [uncovered]
	move.b	d1,(a0)                         	| [...]
l_f226:
	move.b	#0x01,d0                        	| [$f226: lda    #$01]
	jbsr	set_irq_flag_2000              	| [$f228: sta    irq_flag_2000]
	                     	| [$f22b: lda    >$0000]
* A (aka beamy) varies between $9A and $B4 (approx), rather end of frame
* anyway it's read by neither cpu so let's skip it
*	move.b	#0xB4,d0                         	| [...]
*	GET_ADDRESS	beamy_value_6710                     	| [$f22e: sta    $6710]
*	move.b	d0,(a0)                         	| [...]
	rts       	| [$f231: rti]

* this part is only active when player ship materializes or explodes

l_f232:
	jbsr	ship_coordinate_transform_f566                            	| [$f232: jsr    $f566]
	* here beamy = 31 on the arcade machine
	jbsr	init_current_ybeam
	jbsr	update_multiplexed_sprites_f695                            	| [$f235: jsr    $f695]
	jbsr	coordinate_transform_zero_f660                            	| [$f238: jsr    $f660]
	jbsr	update_multiplexed_sprites_f695                            	| [$f23b: jsr    $f695]
	jbsr	enemies_coordinate_transform_f589                            	| [$f23e: jsr    $f589]
	jbsr	update_multiplexed_sprites_f695                            	| [$f241: jsr    $f695]
	jbsr	coordinate_transform_one_f5e7                            	| [$f244: jsr    $f5e7]
	jbsr	update_multiplexed_sprites_f695                            	| [$f247: jsr    $f695]
	jbsr	coordinate_transform_two_f5f3                            	| [$f24a: jsr    $f5f3]
	jbsr	update_multiplexed_sprites_f695                            	| [$f24d: jsr    $f695]
	jbsr	coordinate_transform_three_f5ff                            	| [$f250: jsr    $f5ff]
	jbsr	update_multiplexed_sprites_f695                            	| [$f253: jsr    $f695]
	jbsr	coordinate_transform_four_f60b                            	| [$f256: jsr    $f60b]
	jbsr	update_multiplexed_sprites_f695                            	| [$f259: jsr    $f695]
	jbsr	coordinate_transform_five_f651                            	| [$f25c: jsr    $f651]
	jbsr	update_multiplexed_sprites_f695                            	| [$f25f: jsr    $f695]
	jbsr	coordinate_transform_six_f636                            	| [$f262: jsr    $f636]
	jbsr	update_multiplexed_sprites_f695                            	| [$f265: jsr    $f695]
	jbsr	coordinate_transform_seven_f645                            	| [$f268: jsr    $f645]
	jbsr	update_multiplexed_sprites_f695                            	| [$f26b: jsr    $f695]
	* here beamy = 186 on the arcade machine
	jra	continue_f202                             	| [$f26e: bra    $f202]

compute_coords_f273:
	moveq	#0,d2
	move.w	#rom_start_e000,d2                      	| [$f273: ldx    #$e000]
	GET_U_ADDRESS	0                        	| [$f276: ldb    ,u]
	moveq	#0,d1                            	| [$f27a: clra]
	move.b	(a0),d1                         	| [...]
	beq	l_f2d5                             	| [$f278: beq    $f2d5]
	GET_X_ADDRESS_FROM_REG	d1              	| [$f27b: lda    d,x]
	move.b	(a0),d0                         	| [...]
	GET_DP_ADDRESS	0x08                    	| [$f27d: sta    $08]
	move.b	d0,(a0)                         	| [...]
	move.l	#rom_start_e000+0x400,d2                      	| [$f27f: ldx    #$e400]
	GET_U_ADDRESS	0x3                      	| [$f282: ldb    $3,u]
	moveq	#0,d1
	move.b	(a0),d1                         	| [...]
	add.w	d1,d1
												| [$f284: clra]
												| [$f285: aslb]
													| [$f286: rola]
					
	add.w	d1,d2                            	| [$f287: leax   d,x]
	GET_X_ADDRESS	0x0200                   	| [$f289: ldd    $0200,x]
	LOAD_D                                 	| [$f289: ldd    $0200,x]
	bpl	l_f299                             	| [$f28d: bpl    $f299]
	GET_DP_ADDRESS	0x08                    	| [$f28f: lda    $08]
	move.b	(a0),d0                         	| [...]
	jbsr	multiply_ab                       	| [$f291: mul]
	neg.b	d0                               	| [$f292: nega]
	jmi	l_f29f                             	| [$f293: bmi    $f29f]
	jeq	l_f29f                             	| [$f295: beq    $f29f]
	jra	l_f2d5                             	| [$f297: bra    $f2d5] [uncovered]

l_f299:
	GET_DP_ADDRESS	0x08                    	| [$f299: lda    $08]
	move.b	(a0),d0                         	| [...]
	jbsr	multiply_ab                       	| [$f29b: mul]
	tst.b	d0                               	| [$f29c: tsta]
	bmi	l_f2d5                             	| [$f29d: bmi    $f2d5]
l_f29f:
	add.b	#0x7c,d0                         	| [$f29f: adda   #$7c]
	GET_U_ADDRESS	0                        	| [$f2a1: sta    ,u]
	move.b	d0,(a0)                         	| [...]
	GET_X_ADDRESS	0                        	| [$f2a3: ldd    ,x]
	LOAD_D                                 	| [$f2a3: ldd    ,x]
	bpl	l_f2b1                             	| [$f2a5: bpl    $f2b1]
	GET_DP_ADDRESS	0x08                    	| [$f2a7: lda    $08]
	move.b	(a0),d0                         	| [...]
	jbsr	multiply_ab                       	| [$f2a9: mul]
	neg.b	d0                               	| [$f2aa: nega]
	jmi	l_f2b7                             	| [$f2ab: bmi    $f2b7]
	jeq	l_f2b7                             	| [$f2ad: beq    $f2b7]
	jra	l_f2d5                             	| [$f2af: bra    $f2d5]

l_f2b1:
	GET_DP_ADDRESS	0x08                    	| [$f2b1: lda    $08]
	move.b	(a0),d0                         	| [...]
	jbsr	multiply_ab                       	| [$f2b3: mul]
	tst.b	d0                               	| [$f2b4: tsta]
	bmi	l_f2d5                             	| [$f2b5: bmi    $f2d5]
l_f2b7:
	add.b	#0x78,d0                         	| [$f2b7: adda   #$78]
	GET_U_ADDRESS	0x3                      	| [$f2b9: sta    $3,u]
	move.b	d0,(a0)                         	| [...]
	and.b	#0xc0,d0                         	| [$f2bb: anda   #$c0]
	GET_DP_ADDRESS	0x12                    	| [$f2bd: sta    $12]
	move.b	d0,(a0)                         	| [...]
	move.l	a0,a1
	GET_INDIRECT_ADDRESS	pointer_4211        | [$f2bf: inc    [$4211]]
	addq.b	#1,(a0)                         	| [...]
												| [$f2c3: lda    [$4211]]
	move.b	(a0),d0                         	| [...]
	* reusing address from a1                    	| [$f2c7: adda   $12]
	add.b	(a1),d0                          	| [...]
												| [$f2c9: sta    $12]
	move.b	d0,(a1)                         	| [...]
	GET_DP_ADDRESS	0x0d                    	| [$f2cb: stu    $0d]
	MOVE_W_D4_IN_A0_PLUS_1                         	| [...]
											| [$f2cd: ldb    $0e]
	move.b	(a0),d1                         	| [...]
	lsr.b	#2,d1                            	| [$f2cf: lsrb]
	                            	| [$f2d0: lsrb]
	GET_INDIRECT_ADDRESS	pointer_4211            	| [$f2d1: stb    [$4211]]
	move.b	d1,(a0)                         	| [...]
l_f2d5:
	addq.w	#0x4,d4                         	| [$f2d5: leau   $4,u]
	GET_DP_ADDRESS	0x0c                    	| [$f2d7: dec    $0c]
	subq.b	#1,(a0)                         	| [...]
	bne	compute_coords_f273                             	| [$f2d9: bne    $f273]
	rts                                    	| [$f2db: rts]

l_f2dc:
	move.l	#rom_start_e000,d2                      	| [$f2dc: ldx    #$e000]
	GET_U_ADDRESS	0                        	| [$f2df: ldb    ,u]
	moveq	#0,d1                            	| [$f2e3: clra]
	move.b	(a0),d1                         	| [...]
	beq	l_f35f                             	| [$f2e1: beq    $f35f]
	GET_X_ADDRESS_FROM_REG	d1              	| [$f2e4: lda    d,x]
	move.b	(a0),d0                         	| [...]
	GET_DP_ADDRESS	0x08                    	| [$f2e6: sta    $08]
	move.b	d0,(a0)                         	| [...]
	move.l	#rom_start_e000+0x400,d2                      	| [$f2e8: ldx    #$e400]
	GET_U_ADDRESS	0x3                      	| [$f2eb: ldb    $3,u]
	moveq	#0,d1
	move.b	(a0),d1                         	| [...]
	add.w	d1,d1                            	| [$f2ed: clra]
	                            	| [$f2ee: aslb]
	                             	| [$f2ef: rola]
	add.w	d1,d2                            	| [$f2f0: leax   d,x]
	GET_X_ADDRESS	0x0200                   	| [$f2f2: ldd    $0200,x]
	LOAD_D                                 	| [$f2f2: ldd    $0200,x]
	bpl	l_f302                             	| [$f2f6: bpl    $f302]
	GET_DP_ADDRESS	0x08                    	| [$f2f8: lda    $08]
	move.b	(a0),d0                         	| [...]
	jbsr	multiply_ab                       	| [$f2fa: mul]
	neg.b	d0                               	| [$f2fb: nega]
	jmi	l_f308                             	| [$f2fc: bmi    $f308]
	jeq	l_f308                             	| [$f2fe: beq    $f308]
	jra	l_f35f                             	| [$f300: bra    $f35f]

l_f302:
	GET_DP_ADDRESS	0x08                    	| [$f302: lda    $08]
	move.b	(a0),d0                         	| [...]
	jbsr	multiply_ab                       	| [$f304: mul]
	tst.b	d0                               	| [$f305: tsta]
	bmi	l_f35f                             	| [$f306: bmi    $f35f]
l_f308:
	GET_U_ADDRESS	0x2                      	| [$f308: ldb    $2,u]
	move.b	(a0),d1                         	| [...]
	and.b	#0x10,d1                         	| [$f30a: andb   #$10]
	bne	l_f312                             	| [$f30c: bne    $f312]
	add.b	#0x7c,d0                         	| [$f30e: adda   #$7c]
	bra	l_f314                             	| [$f310: bra    $f314]

l_f312:
	add.b	#0x78,d0                         	| [$f312: adda   #$78]
l_f314:
	GET_U_ADDRESS	0                        	| [$f314: sta    ,u]
	move.b	d0,(a0)                         	| [...]
	add.b	#0x08,d0                         	| [$f316: adda   #$08]
	GET_U_ADDRESS	0x4                      	| [$f318: sta    $4,u]
	move.b	d0,(a0)                         	| [...]
	GET_X_ADDRESS	0                        	| [$f31a: ldd    ,x]
	LOAD_D                                 	| [$f31a: ldd    ,x]
	bpl	l_f328                             	| [$f31c: bpl    $f328]
	GET_DP_ADDRESS	0x08                    	| [$f31e: lda    $08]
	move.b	(a0),d0                         	| [...]
	jbsr	multiply_ab                       	| [$f320: mul]
	neg.b	d0                               	| [$f321: nega]
	jmi	l_f32e                             	| [$f322: bmi    $f32e]
	jeq	l_f32e                             	| [$f324: beq    $f32e]
	jra	l_f35f                             	| [$f326: bra    $f35f]

l_f328:
	GET_DP_ADDRESS	0x08                    	| [$f328: lda    $08]
	move.b	(a0),d0                         	| [...]
	jbsr	multiply_ab                       	| [$f32a: mul]
	tst.b	d0                               	| [$f32b: tsta]
	bmi	l_f35f                             	| [$f32c: bmi    $f35f]
l_f32e:
	add.b	#0x78,d0                         	| [$f32e: adda   #$78]
	GET_U_ADDRESS	0x3                      	| [$f330: sta    $3,u]
	move.b	d0,(a0)                         	| [...]
	move.b	d0,(4,a0)                         	| [$f332: sta    $7,u]
	                      	| [$f334: lda    $2,u]
	move.b	(-1,a0),d0                         	| [...] writes to 2
	and.b	#0x10,d0                         	| [$f336: anda   #$10]
	beq	l_f368                             	| [$f338: beq    $f368]
												| [$f33a: lda    $3,u]
	move.b	(a0),d0                         	| [...]
	and.b	#0xc0,d0                         	| [$f33c: anda   #$c0]
	GET_DP_ADDRESS	0x12                    	| [$f33e: sta    $12]
	exg	a0,a1			| save address for below
	move.b	d0,(a0)                         	| [...]
	GET_INDIRECT_ADDRESS	pointer_4211            	| [$f340: lda    [$4211]]
	move.b	(a0),d0                         	| [...]
	add.b	#0x02,d0                         	| [$f344: adda   #$02]
	move.b	d0,(a0)								| [$f346: sta    [$4211]]
	add.b	(a1),d0			                    	| [$f34a: adda   $12]
	move.b	d0,(a1)                    	        | [$f34c: sta    $12]
	GET_DP_ADDRESS	0x0d                    	| [$f34e: stu    $0d]
	MOVE_W_D4_IN_A0_PLUS_1                         	| [...]
			                   	| [$f350: ldb    $0e]
	move.b	(a0),d1                         	| [...]
	* divide by 4 to find sprite index
	lsr.b	#2,d1                            	| [$f352: lsrb]
												| [$f353: lsrb]
	* store 2 consecutive sprite indexes in area pointed by 4211 (decreasing)
	* probably to handle "big" sprites like big approaching iceberg

	GET_INDIRECT_ADDRESS	pointer_4211            	| [$f354: stb    [$4211]]
	move.b	d1,(a0)                         	| [...]
	GET_DP_ADDRESS	0x12                    	| [$f358: dec    $12]
	subq.b	#1,(a0)                         	| [...] decrease pointer in 4211
	addq.b	#1,d1                           	| [$f35a: incb]
	GET_INDIRECT_ADDRESS	pointer_4211        | [$f35b: stb    [$4211]]
	move.b	d1,(a0)                         	| [...]
l_f35f:
	addq.w	#0x8,d4                         	| [$f35f: leau   $8,u]
	GET_DP_ADDRESS	0x0c                    	| [$f361: dec    $0c]
	subq.b	#1,(a0)                         	| [...]
	bne	l_f2dc                             	| [$f363: lbne   $f2dc]
	rts                                    	| [$f367: rts]

l_f368:
	* a0 is already set to address 3                      	| [$f368: lda    $3,u]
	move.b	(a0),d0                         	| [...]
	and.b	#0xc0,d0                         	| [$f36a: anda   #$c0]
	GET_DP_ADDRESS	0x12                    	| [$f36c: sta    $12]
	move.b	d0,(a0)                         	| [...]
	move.l	a0,a1			| save address for below
	GET_INDIRECT_ADDRESS	pointer_4211            	| [$f36e: inc    [$4211]]
	addq.b	#1,(a0)                         	| [...]
												| [$f372: lda    [$4211]]
	move.b	(a0),d0                         	| [...]
									| [$f376: adda   $12]
	add.b	(a1),d0                          	| [...]
												| [$f378: sta    $12]
	move.b	d0,(a1)                         	| [...]
	GET_DP_ADDRESS	0x0d                    	| [$f37a: stu    $0d]
	MOVE_W_D4_IN_A0_PLUS_1                         	| [...]
											| [$f37c: ldb    $0e]
	move.b	(a0),d1                         	| [...]
	lsr.b	#2,d1                            	| [$f37e: lsrb]
												| [$f37f: lsrb]
	GET_INDIRECT_ADDRESS	pointer_4211            	| [$f380: stb    [$4211]]
	move.b	d1,(a0)                         	| [...]
	bra	l_f35f                             	| [$f384: bra    $f35f]

compute_coords_f386:
	move.l	#rom_start_e000,d2                      	| [$f386: ldx    #$e000] ROM start address
	GET_U_ADDRESS	0                        	| [$f389: ldb    ,u]
	moveq	#0,d1                            	| [$f38d: clra]
	move.b	(a0),d1                         	| [...]
	beq	l_f3ea                             	| [$f38b: beq    $f3ea]
	GET_X_ADDRESS_FROM_REG	d1              	| [$f38e: lda    d,x]
	move.b	(a0),d0                         	| [...]
	GET_DP_ADDRESS	0x08                    	| [$f390: sta    $08]
	move.b	d0,(a0)                         	| [...]
	moveq	#0,d2
	move.w	#rom_start_e000+0x400,d2                      	| [$f392: ldx    #$e400]
	GET_U_ADDRESS	0x3                      	| [$f395: ldb    $3,u]
	moveq	#0,d1
	move.b	(a0),d1                         	| [...]
	add.w	d1,d1                            	| [$f397: clra]
	                            	| [$f398: aslb]
	                             	| [$f399: rola]
	add.w	d1,d2                            	| [$f39a: leax   d,x]
	GET_X_ADDRESS	0x0200                   	| [$f39c: ldd    $0200,x]
	LOAD_D                                 	| [$f39c: ldd    $0200,x]
	bpl	l_f3ac                             	| [$f3a0: bpl    $f3ac]
	GET_DP_ADDRESS	0x08                    	| [$f3a2: lda    $08]
	move.b	(a0),d0                         	| [...]
	jbsr	multiply_ab                       	| [$f3a4: mul]
	neg.b	d0                               	| [$f3a5: nega]
	bmi	l_f3b2                             	| [$f3a6: bmi    $f3b2]
	beq	l_f3b2                             	| [$f3a8: beq    $f3b2]
	bra	l_f3ea                             	| [$f3aa: bra    $f3ea]

l_f3ac:
	GET_DP_ADDRESS	0x08                    	| [$f3ac: lda    $08]
	move.b	(a0),d0                         	| [...]
	jbsr	multiply_ab                       	| [$f3ae: mul]
	tst.b	d0                               	| [$f3af: tsta]
	bmi	l_f3ea                             	| [$f3b0: bmi    $f3ea]
l_f3b2:
	add.b	#0x7c,d0                         	| [$f3b2: adda   #$7c]
	GET_U_ADDRESS	0                        	| [$f3b4: sta    ,u]
	move.b	d0,(a0)                         	| [...]
	GET_X_ADDRESS	0                        	| [$f3b6: ldd    ,x]

	LOAD_D                                 	| [$f3b6: ldd    ,x]
	bpl	l_f3c4                             	| [$f3b8: bpl    $f3c4]
	GET_DP_ADDRESS	0x08                    	| [$f3ba: lda    $08]
	move.b	(a0),d0                         	| [...]
	jbsr	multiply_ab                       	| [$f3bc: mul]
	neg.b	d0                               	| [$f3bd: nega]
	jmi	l_f3ca                             	| [$f3be: bmi    $f3ca]
	jeq	l_f3ca                             	| [$f3c0: beq    $f3ca]
	jra	l_f3ea                             	| [$f3c2: bra    $f3ea]

l_f3c4:
	GET_DP_ADDRESS	0x08                    	| [$f3c4: lda    $08]
	move.b	(a0),d0                         	| [...]
	jbsr	multiply_ab                       	| [$f3c6: mul]
	tst.b	d0                               	| [$f3c7: tsta]
	bmi	l_f3ea                             	| [$f3c8: bmi    $f3ea]
l_f3ca:
	add.b	#0x78,d0                         	| [$f3ca: adda   #$78]
	GET_U_ADDRESS	0x3                      	| [$f3cc: sta    $3,u]
	move.b	d0,(a0)                         	| [...]
	and.b	#0xc0,d0                         	| [$f3ce: anda   #$c0]
	GET_DP_ADDRESS	0x12                    	| [$f3d0: sta    $12]
	move.b	d0,(a0)                         	| [...]
	move.l	a0,a1
	GET_INDIRECT_ADDRESS	pointer_4211            	| [$f3d2: inc    [$4211]]
	addq.b	#1,(a0)                         	| [...]	            	
	move.b	(a0),d0                         	| [$f3d6: lda    [$4211]]
	* using saved address in a1               	| [$f3da: adda   $12]
	add.b	(a1),d0                          	| [...]
	move.b	d0,(a1)                         	| [$f3dc: sta    $12]
	GET_DP_ADDRESS	0x0d                    	| [$f3de: stu    $0d]
	MOVE_W_D4_IN_A0_PLUS_1                         	| [...]
											| [$f3e0: ldb    $0e]
	move.b	(a0),d1                         	| [...]
	lsr.b	#2,d1                            	| [$f3e2: lsrb]
												| [$f3e3: lsrb]
	add.b	#0x40,d1                         	| [$f3e4: addb   #$40]
	GET_INDIRECT_ADDRESS	pointer_4211            	| [$f3e6: stb    [$4211]]
	move.b	d1,(a0)                         	| [...]
l_f3ea:
	addq.w	#0x4,d4                         	| [$f3ea: leau   $4,u]
	GET_DP_ADDRESS	0x0c                    	| [$f3ec: dec    $0c]
	subq.b	#1,(a0)                         	| [...]
	bne	compute_coords_f386                             	| [$f3ee: bne    $f386]
	rts                                    	| [$f3f0: rts]

l_f3f1:
	moveq	#0,d2
	move.w	#rom_start_e000,d2                      	| [$f3f1: ldx    #$e000]
	GET_U_ADDRESS	0                        	| [$f3f4: ldb    ,u]
	moveq	#0,d1                            	| [$f3fa: clra]
	move.b	(a0),d1                         	| [...]
	beq	l_f482                             	| [$f3f6: lbeq   $f482]
	GET_X_ADDRESS_FROM_REG	d1              	| [$f3fb: lda    d,x]
	move.b	(a0),d0                         	| [...]
	GET_DP_ADDRESS	0x08                    	| [$f3fd: sta    $08]
	move.b	d0,(a0)                         	| [...]
	moveq	#0,d2
	move.w	#rom_start_e000+0x400,d2                      	| [$f3ff: ldx    #$e400]
	GET_U_ADDRESS	0x3                      	| [$f402: ldb    $3,u]
	moveq	#0,d1
	move.b	(a0),d1                         	| [...]
	add.w	d1,d1                            	| [$f404: clra]
	                            	| [$f405: aslb]
	                             	| [$f406: rola]
	add.w	d1,d2                            	| [$f407: leax   d,x]
	GET_X_ADDRESS	0x0200                   	| [$f409: ldd    $0200,x]
	LOAD_D                                 	| [$f409: ldd    $0200,x]
	bpl	l_f419                             	| [$f40d: bpl    $f419]
	GET_DP_ADDRESS	0x08                    	| [$f40f: lda    $08]
	move.b	(a0),d0                         	| [...]
	jbsr	multiply_ab                       	| [$f411: mul]
	neg.b	d0                               	| [$f412: nega]
	bmi	l_f41f                             	| [$f413: bmi    $f41f]
	beq	l_f41f                             	| [$f415: beq    $f41f]
	bra	l_f482                             	| [$f417: bra    $f482]

l_f419:
	GET_DP_ADDRESS	0x08                    	| [$f419: lda    $08]
	move.b	(a0),d0                         	| [...]
	jbsr	multiply_ab                       	| [$f41b: mul]
	tst.b	d0                               	| [$f41c: tsta]
	bmi	l_f482                             	| [$f41d: bmi    $f482]
l_f41f:
	add.b	#0x7c,d0                         	| [$f41f: adda   #$7c]
	GET_U_ADDRESS	0                        	| [$f421: sta    ,u]
	move.b	d0,(a0)                         	| [...]
	add.b	#0xfc,d0                         	| [$f423: adda   #$fc]
	GET_U_ADDRESS	0x23                     	| [$f425: sta    $23,u]
	move.b	d0,(a0)                         	| [...]
	GET_X_ADDRESS	0                        	| [$f428: ldd    ,x]
	LOAD_D                                 	| [$f428: ldd    ,x]
	bpl	l_f436                             	| [$f42a: bpl    $f436]
	GET_DP_ADDRESS	0x08                    	| [$f42c: lda    $08]
	move.b	(a0),d0                         	| [...]
	jbsr	multiply_ab                       	| [$f42e: mul]
	neg.b	d0                               	| [$f42f: nega]
	bmi	l_f43c                             	| [$f430: bmi    $f43c]
	beq	l_f43c                             	| [$f432: beq    $f43c]
	bra	l_f482                             	| [$f434: bra    $f482]

l_f436:
	GET_DP_ADDRESS	0x08                    	| [$f436: lda    $08]
	move.b	(a0),d0                         	| [...]
	jbsr	multiply_ab                       	| [$f438: mul]
	tst.b	d0                               	| [$f439: tsta]
	bmi	l_f482                             	| [$f43a: bmi    $f482]
l_f43c:
	add.b	#0x78,d0                         	| [$f43c: adda   #$78]
	GET_U_ADDRESS	0x3                      	| [$f43e: sta    $3,u]
	move.b	d0,(a0)                         	| [...]
												| [$f440: ldb    $3,u]
	move.b	(a0),d1                         	| [...]
	add.b	#0x04,d1                         	| [$f442: addb   #$04]
	GET_U_ADDRESS	0x20                     	| [$f444: stb    $20,u]
	move.b	d1,(a0)                         	| [...]
	and.b	#0xc0,d0                         	| [$f447: anda   #$c0]
	GET_DP_ADDRESS	0x12                    	| [$f449: sta    $12]
	move.b	d0,(a0)                         	| [...]
	move.l	a0,a1
	GET_INDIRECT_ADDRESS	pointer_4211            	| [$f44b: inc    [$4211]]
	addq.b	#1,(a0)                         	| [...]
	            	| [$f44f: lda    [$4211]]
	move.b	(a0),d0                         	| [...]
	* reusing address in a1                    	| [$f453: adda   $12]
	add.b	(a1),d0                          	| [...]	                    	
	move.b	d0,(a1)                         	| [$f455: sta    $12]
	GET_DP_ADDRESS	0x0d                    	| [$f457: stu    $0d]
	MOVE_W_D4_IN_A0_PLUS_1                         	| [...]
										| [$f459: ldb    $0e]
	move.b	(a0),d1                         	| [...]
	* convert address to index of sprite (1 sprite = 4 bytes)
	lsr.b	#2,d1                            	| [$f45b: lsrb]
												| [$f45c: lsrb]
	add.b	#0x40,d1                         	| [$f45d: addb   #$40]
	GET_INDIRECT_ADDRESS	pointer_4211            	| [$f45f: stb    [$4211]]
	move.b	d1,(a0)                         	| [...]
	GET_U_ADDRESS	0x23                     	| [$f463: lda    $23,u]
	move.b	(a0),d0                         	| [...]
	and.b	#0xc0,d0                         	| [$f466: anda   #$c0]
	GET_DP_ADDRESS	0x12                    	| [$f468: sta    $12]
	move.b	d0,(a0)                         	| [...]
	move.l	a0,a1
	GET_INDIRECT_ADDRESS	pointer_4211            	| [$f46a: inc    [$4211]]
	addq.b	#1,(a0)                         	| [...]	            	
	move.b	(a0),d0                         	| [$f46e: lda    [$4211]]
	* used stored A1                    	| [$f472: adda   $12]
	add.b	(a1),d0                          	| [...]                 	
	move.b	d0,(a1)                         	| [$f474: sta    $12]
	GET_DP_ADDRESS	0x0d                    	| [$f476: stu    $0d]
	MOVE_W_D4_IN_A0_PLUS_1                         	| [...]
											| [$f478: ldb    $0e]
	move.b	(a0),d1                         	| [...]
	lsr.b	#2,d1                            	| [$f47a: lsrb]
												| [$f47b: lsrb]
	add.b	#0x48,d1                         	| [$f47c: addb   #$48]
	GET_INDIRECT_ADDRESS	pointer_4211            	| [$f47e: stb    [$4211]]
	move.b	d1,(a0)                         	| [...]
l_f482:
	addq.w	#0x4,d4                         	| [$f482: leau   $4,u]
	GET_DP_ADDRESS	0x0c                    	| [$f484: dec    $0c]
	subq.b	#1,(a0)                         	| [...]
	bne	l_f3f1                             	| [$f486: lbne   $f3f1]
	rts                                    	| [$f48a: rts]

* reads from 6000 and updates 4040 while 6200 is being updated by main cpu
try_to_update_all_sprites_odd_f48b:
	moveq	#0,d2
	move.w	#0x64c0,d2                      	| [$f48b: ldx    #$64c0]  contains the number of odd sprites to update
	GET_X_ADDRESS	0                        	| [$f48e: lda    ,x+]
	addq.w	#1,d2
	move.b	(a0),d0                         	| [...]
	GET_DP_ADDRESS	number_of_sprites_to_update_09       | [$f490: sta    $09]
	move.b	d0,(a0)                         	| [...]
	GET_DP_ADDRESS	0x00                    	| [$f492: stx    $00]
	move.w	d2,(a0)                         	| [...]		updates $4200 pointer
	move.w	#sprite_ram_4040,d4             	| [$f494: ldu    #sprite_ram_4040]
	GET_DP_ADDRESS	unknown_0b                    	| [$f497: clr    $0b]
	clr.b	(a0)                         		| [...]
												| [$f499: lda    #$30] all 48 sprites
												| [$f49b: sta    $0a]
	move.b	#0x30,-(a0)                         	| [...]
l_f49d:
	GET_DP_ADDRESS	unknown_0b                    	| [$f49d: lda    $0b]
	move.b	(a0),d0                         	| [...]
	cmp.b	#0x04,d0                         	| [$f49f: cmpa   #$04]
	jcc	hide_rest_of_sprites_f4c6                             	| [$f4a1: jcc    $f4c6]
l_f4a3:
	GET_DP_ADDRESS	number_of_sprites_to_update_09                    	| [$f4a3: lda    $09]
	move.b	(a0),d0                         	| [...]
	beq	l_f4d0                             	| [$f4a5: beq    $f4d0]
	* gives the sprite number to update, driven by shared memory in 65xx
	GET_INDIRECT_ADDRESS	sprite_index_pointer_4200            	| [$f4a7: ldb    [$4200]]
	moveq	#0,d1
	move.b	(a0),d1                         	| [...]
	add.w	d1,d1                  	| [$f4ab: clra]
	add.w	d1,d1                  	| [$f4ac: aslb]
	                             	| [$f4ad: rola]
	                            	| [$f4ae: aslb]
	                             	| [$f4af: rola]
	add.w	#shared_memory_6000,d1           	| [$f4b0: addd   #shared_memory_6000]
	move.w	d1,d2                           	| [$f4b3: tfr    d,x]
	GET_X_ADDRESS	0                        	| [$f4b5: ldd    ,x++]


	move.l	(a0),d0
	addq.w	#4,d2
	                                 	
	GET_U_ADDRESS	0                        	| [$f4b7: std    ,u++]
	addq.w	#4,d4
	move.l	d0,(a0)                	| [...]
	
	jbsr	osd_queue_sprite


								| [$f4b9: ldd    ,x]
									| [$f4bb: std    ,u++]
				
						| [...]
	GET_DP_ADDRESS	sprite_index_pointer_4200_lsb_01                    	| [$f4bd: inc    $01]
	addq.b	#1,(a0)                         	| [...]  increase 4201 (lsb of pointer on 64xx)
	GET_DP_ADDRESS	number_of_sprites_to_update_09                    	| [$f4bf: dec    $09]
	subq.b	#1,(a0)+                         	| [...]
												| [$f4c1: dec    $0a]
	subq.b	#1,(a0)                         	| [...]
	bne	l_f4a3                             	| [$f4c3: bne    $f4a3]
	rts                                    	| [$f4c5: rts]

hide_rest_of_sprites_f4c6:
	moveq	#0,d0                            	| [$f4c6: clra]
l_f4c7:
	GET_U_ADDRESS	0x3                      	| [$f4c7: sta    $3,u]
	move.b	d0,(a0)                         	| [...]
	addq.w	#0x4,d4                         	| [$f4c9: leau   $4,u]
	GET_DP_ADDRESS	number_of_sprites_to_update_total_0a                    	| [$f4cb: dec    $0a]
	subq.b	#1,(a0)                         	| [...]
	jne	l_f4c7                             	| [$f4cd: bne    $f4c7]
	rts                                    	| [$f4cf: rts]

l_f4d0:
	GET_DP_ADDRESS	sprite_index_pointer_4200_lsb_01                    	| [$f4d0: lda    $01]
	move.b	(a0),d0                         	| [...]
	move.l	a0,a1
	and.b	#0xc0,d0                         	| [$f4d2: anda   #$c0]
	sub.b	#0x40,d0                         	| [$f4d4: suba   #$40]
										| [$f4d6: sta    $01]
	move.b	d0,(a0)                         	| [...]
	GET_INDIRECT_ADDRESS	sprite_index_pointer_4200            	| [$f4d8: lda    [$4200]]
	move.b	(a0),d0                         	| [...]
	GET_DP_ADDRESS	number_of_sprites_to_update_09                    	| [$f4dc: sta    $09]
	move.b	d0,(a0)                         	| [...]
	                    	| [$f4de: inc    $01]
	addq.b	#1,(a1)                         	| [...]
	GET_DP_ADDRESS	unknown_0b                    	| [$f4e0: inc    $0b]
	addq.b	#1,(a0)                         	| [...]
	bra	l_f49d                             	| [$f4e2: bra    $f49d]

* reads from 6200 and updates 4040 while 6000 is being updated by main cpu
try_to_update_all_sprites_even_f4e4:
	moveq	#0,d2
	move.w	#0x65c0,d2                      	| [$f4e4: ldx    #$65c0] contains the number of even sprites to update
	GET_X_ADDRESS	0                        	| [$f4e7: lda    ,x+]
	addq.w	#1,d2
	move.b	(a0),d0                         	| [...]
	GET_DP_ADDRESS	number_of_sprites_to_update_09                    	| [$f4e9: sta    $09]
	move.b	d0,(a0)                         	| [...]
	GET_DP_ADDRESS	0x00                    	| [$f4eb: stx    $00]
	move.w	d2,(a0)                         	| [...] store $65C1 in $4200
	move.w	#sprite_ram_4040,d4             	| [$f4ed: ldu    #sprite_ram_4040]
	GET_DP_ADDRESS	unknown_0b                    	| [$f4f0: clr    $0b]
	move.b	#0,(a0)                         	| [...]
												| [$f4f2: lda    #$30] 48 (all) max number of sprites (not always reached)
	                    	
	move.b	#0x30,-(a0)            | [$f4f4: sta    number_of_sprites_to_update_total_0a]
l_f4f6:
	GET_DP_ADDRESS	unknown_0b                    	| [$f4f6: lda    $0b]
	move.b	(a0),d0                         	| [...]
	cmp.b	#0x04,d0                         	| [$f4f8: cmpa   #$04]
	jcc	hide_rest_of_sprites_f51f                             	| [$f4fa: jcc    $f51f]
l_f4fc:
	GET_DP_ADDRESS	number_of_sprites_to_update_09                    	| [$f4fc: lda    $09]
	move.b	(a0),d0                         	| [...]
	beq	l_f529                             	| [$f4fe: beq    $f529]
	* compute offset for source buffer
	GET_INDIRECT_ADDRESS	sprite_index_pointer_4200            	| [$f500: ldb    [$4200]]
	moveq	#0,d1
	move.b	(a0),d1                         	| [...]
	add.w	d1,d1                            	| [$f504: clra]
	add.w	d1,d1                            	| [$f505: aslb]
	                             	| [$f506: rola]
	                            	| [$f507: aslb]
	                             	| [$f508: rola]
	add.w	#shared_memory_6000+0x200,d1                       	| [$f509: addd   #$6200]
	move.w	d1,d2                           	| [$f50c: tfr    d,x]
	GET_X_ADDRESS	0                        	| [$f50e: ldd    ,x++]
	move.l	(a0),d0
	addq.w	#4,d2
	GET_U_ADDRESS	0                        	| [$f510: std    ,u++]
	addq.w	#4,d4
	
	jbsr	osd_queue_sprite
	
	move.l	d0,(a0)                	| [...]
								| [$f512: ldd    ,x]
							| [$f512: ldd    ,x]
								| [$f514: std    ,u++]
			
	* increase pointer on sprite indexes (sprite_index_pointer_4200)
	GET_DP_ADDRESS	sprite_index_pointer_4200_lsb_01                    	| [$f516: inc    $01]
	addq.b	#1,(a0)                         	| [...]											| [$f51a: dec    $0a]
	GET_DP_ADDRESS	number_of_sprites_to_update_09                    	| [$f518: dec    $09]
	subq.b	#1,(a0)+                         	| [...]
	subq.b	#1,(a0)                         	| [...] 420A total number of hardware sprites
	bne	l_f4fc                             	| [$f51c: bne    $f4fc]
	rts                                    	| [$f51e: rts]

hide_rest_of_sprites_f51f:
	moveq	#0,d0                            	| [$f51f: clra]
l_f520:
	GET_U_ADDRESS	0x3                      	| [$f520: sta    $3,u]
	move.b	d0,(a0)                         	| [...]
	addq.w	#0x4,d4                         	| [$f522: leau   $4,u]
	GET_DP_ADDRESS	number_of_sprites_to_update_total_0a                    	| [$f524: dec    $0a]
	subq.b	#1,(a0)                         	| [...]
	bne	l_f520                             	| [$f526: bne    $f520]
	rts                                    	| [$f528: rts]

l_f529:
	GET_DP_ADDRESS	sprite_index_pointer_4200_lsb_01                    	| [$f529: lda    $01]
	move.b	(a0),d0                         	| [...]
	move.l	a0,a1
	and.b	#0xc0,d0                         	| [$f52b: anda   #$c0]
	sub.b	#0x40,d0                         	| [$f52d: suba   #$40]
	move.b	d0,(a0)								| [$f52f: sta    $01]
	GET_INDIRECT_ADDRESS	sprite_index_pointer_4200            	| [$f531: lda    [$4200]]
	move.b	(a0),d0                         	| [...]
	GET_DP_ADDRESS	number_of_sprites_to_update_09                    	| [$f535: sta    $09]
	move.b	d0,(a0)                         	| [...]
	                    	| [$f537: inc    $01]
	addq.b	#1,(a1)                         	| [...]
	GET_DP_ADDRESS	unknown_0b                    	| [$f539: inc    $0b]
	addq.b	#1,(a0)                         	| [...]
	jra	l_f4f6                             	| [$f53b: bra    $f4f6]

	* copy sprites from shared memory with real sprite memory, no changes
	* no multiplexing, no coordinate transformation
	* not called anymore
	* (only active at bootup, so useless)
*sync_sprites_no_change_f54a:
*	move.w	#shared_memory_6000,d4          	| [$f54a: ldu    #shared_memory_6000]
*	move.w	#sprite_ram_4040,d3             	| [$f54d: ldy    #sprite_ram_4040]
*	move.w	#0x0030-1,d2                      	| [$f551: ldx    #$0030]
*	GET_Y_ADDRESS	0                        	| [$f556: std    ,y++]
*	move.l	a0,a1
*	GET_U_ADDRESS	0                        	| [$f554: ldd    ,u++]
*l_f554:
*	move.l	(a0)+,(a1)+							| [$f554: ldd    ,u++]
*												| [$f554: ldd    ,u++]
*												| [$f558: ldd    ,u++]
*												| [$f55a: std    ,y++]
*												| [$f55c: leax   -$1,x]
*	dbf		d2,l_f554                             	| [$f55e: bne    $f554]
*	move.b	#0x01,d0                        	| [$f560: lda    #$01]
*	jbsr	set_irq_flag_2000              	| [$f562: sta    irq_flag_2000]
*	rts       	| [$f565: rti]
	
ship_coordinate_transform_f566:
	GET_DP_ADDRESS	0x0f                    	| [$f566: ldu    $0f]
	move.l	a0,-(a7)				| save address for later
	MOVE_W_A0_IN_D4                         	| [...]
	moveq	#0,d1                            	| [$f568: clrb]
l_f569:
	GET_U_ADDRESS	0x3                      	| [$f569: lda    $3,u]
	move.b	(a0),d0                         	| [...]
	and.b	#0xc0,d0                         	| [$f56b: anda   #$c0]
	GET_DP_ADDRESS	0x12                    	| [$f56d: sta    $12]
	move.b	d0,(a0)                         	| [...]
	move.l	a0,a1
	GET_INDIRECT_ADDRESS	pointer_4211            	| [$f56f: inc    [$4211]]
	addq.b	#1,(a0)                         	| [...]
												| [$f573: lda    [$4211]]
	move.b	(a0),d0                         	| [...]
	* reused address from a1					| [$f577: adda   $12]
	add.b	(a1),d0                          	| [...]
	                    	| [$f579: sta    $12]
	move.b	d0,(a1)                         	| [...]
	GET_INDIRECT_ADDRESS	pointer_4211            	| [$f57b: stb    [$4211]]
	move.b	d1,(a0)                         	| [...]
	addq.w	#0x4,d4                         	| [$f57f: leau   $4,u]
	addq.b	#1,d1                           	| [$f581: incb]
	cmp.b	#0x04,d1                         	| [$f582: cmpb   #$04]
	jcs	l_f569                             	| [$f584: jcs    $f569]
	move.l	(a7)+,a0                    	| [$f586: stu    $0f]
	MOVE_W_D4_IN_A0                         	| [...]
	rts                                    	| [$f588: rts]

enemies_coordinate_transform_f589:
	GET_ADDRESS	update_sequence_control_flag_67fc   | [$f589: lda    $67fc]
	move.b	(a0),d0                         	| [...]
	bne	l_f59e                             	| [$f58c: bne    $f59e]
	GET_DP_ADDRESS	0x0f                    	| [$f58e: ldu    $0f]
	move.l	a0,-(a7)				| save address for later
	MOVE_W_A0_IN_D4                  	| [...]
	sub.w	#0x0128,d4                       	| [$f590: leau   -$0128,u]
	                        	| [$f594: lda    #$0a]
	move.b	#0xa,(0xC-0xF,a0)                    	| [$f596: sta    $0c]
	jbsr	l_f2dc                            	| [$f598: jsr    $f2dc]
	move.l	(a7)+,a0	                    	| [$f59b: stu    $0f]
	MOVE_W_D4_IN_A0                         	| [...]
	rts                                    	| [$f59d: rts]

l_f59e:
	GET_DP_ADDRESS	0x0f                    	| [$f59e: ldu    $0f]
	move.l	a0,-(a7)
	MOVE_W_A0_IN_D4                  	| [...]
	sub.w	#0x0128,d4                       	| [$f5a0: leau   -$0128,u]
	
	lea		(0xC-0xF,a0),a0                        	| [$f5a4: lda    #$01]
	move.b	#0x01,(a0)                   	| [$f5a6: sta    $0c]
	move.l	a0,-(a7)						| save address for later
	jbsr	l_f2dc                            	| [$f5a8: jsr    $f2dc]
	move.l	(a7)+,a0
	move.b	#0x09,d0                        	| [$f5ab: lda    #$09]
	move.b	d0,(a0)								| [$f5ad: sta    $0c]
l_f5af:
	GET_U_ADDRESS	0                        	| [$f5af: lda    ,u]
	move.b	(a0),d0                         	| [...]
	beq	l_f5de                             	| [$f5b1: beq    $f5de]
	add.b	#0x08,d0                         	| [$f5b3: adda   #$08]
	GET_U_ADDRESS	0x4                      	| [$f5b5: sta    $4,u]
	move.b	d0,(a0)                         	| [...]
												| [$f5b7: lda    $3,u]
	move.b	-(a0),d0                         	| [...]
	GET_U_ADDRESS	0x7                      	| [$f5b9: sta    $7,u]
	move.b	d0,(a0)                         	| [...]
	and.b	#0xc0,d0                         	| [$f5bb: anda   #$c0]
	GET_DP_ADDRESS	0x12                    	| [$f5bd: sta    $12]
	move.b	d0,(a0)                         	| [...]
	move.l 	a0,-(a7)
	GET_INDIRECT_ADDRESS	pointer_4211            	| [$f5bf: lda    [$4211]]
	move.b	(a0),d0                         	| [...]
	add.b	#0x02,d0                         	| [$f5c3: adda   #$02]
									| [$f5c5: sta    [$4211]]
	move.b	d0,(a0)                         	| [...]
	move.l	(a7)+,a0                    	| [$f5c9: adda   $12]
	add.b	(a0),d0                          	| [...]
										| [$f5cb: sta    $12]
	move.b	d0,(a0)                         	| [...]
	GET_DP_ADDRESS	0x0d                    	| [$f5cd: stu    $0d]
	MOVE_W_D4_IN_A0_PLUS_1                         	| [...]
												| [$f5cf: ldb    $0e]
	move.b	(a0),d1                         	| [...]
	lsr.b	#2,d1                            	| [$f5d1: lsrb]
	                            	| [$f5d2: lsrb]
	GET_INDIRECT_ADDRESS	pointer_4211            	| [$f5d3: stb    [$4211]]
	move.b	d1,(a0)                         	| [...]
	GET_DP_ADDRESS	0x12                    	| [$f5d7: dec    $12]
	subq.b	#1,(a0)                         	| [...]
	addq.b	#1,d1                           	| [$f5d9: incb]
	GET_INDIRECT_ADDRESS	pointer_4211            	| [$f5da: stb    [$4211]]
	move.b	d1,(a0)                         	| [...]
l_f5de:
	addq.w	#0x8,d4                         	| [$f5de: leau   $8,u]
	GET_DP_ADDRESS	0x0c                    	| [$f5e0: dec    $0c]
	subq.b	#1,(a0)                         	| [...]
	jne	l_f5af                             	| [$f5e2: bne    $f5af]
	move.l		(a7)+,a0                    	| [$f5e4: stu    $0f]
	MOVE_W_D4_IN_A0                	| [...]
	rts                                    	| [$f5e6: rts]

coordinate_transform_one_f5e7:
	GET_DP_ADDRESS	0x0f                    	| [$f5e7: ldu    $0f]
	move.l		a0,-(a7)
	MOVE_W_A0_IN_D4                         	| [...]
												| [$f5e9: lda    #$0a]
	move.b	#0xa,(0xC-0xF,a0)                    	| [$f5eb: sta    $0c]
	jbsr	compute_coords_f273                            	| [$f5ed: jsr    $f273]
	move.l		(a7)+,a0                    	| [$f5f0: stu    $0f]
	MOVE_W_D4_IN_A0                	| [...]
	rts                                    	| [$f5f2: rts]

coordinate_transform_two_f5f3:
	GET_DP_ADDRESS	0x0f                    	| [$f5f3: ldu    $0f]
	move.l		a0,-(a7)
	MOVE_W_A0_IN_D4                         	| [...]
	                        	| [$f5f5: lda    #$08]
	move.b	#0x08,(0xC-0xF,a0)                    	| [$f5f7: sta    $0c]
	jbsr	compute_coords_f273                            	| [$f5f9: jsr    $f273]
	move.l		(a7)+,a0                    	| [$f5fc: stu    $0f]
	MOVE_W_D4_IN_A0                	| [...]
	rts                                    	| [$f5fe: rts]

coordinate_transform_three_f5ff:
	GET_DP_ADDRESS	0x0f                    	| [$f5ff: ldu    $0f]
	move.l		a0,-(a7)
	MOVE_W_A0_IN_D4                         	| [...]
												| [$f601: lda    #$0a]
	move.b	#0xa,(0xC-0xF,a0)                    	| [$f603: sta    $0c]
	jbsr	compute_coords_f273                            	| [$f605: jsr    $f273]
	move.l		(a7)+,a0                    	| [$f608: stu    $0f]
	MOVE_W_D4_IN_A0                	| [...]
	rts                                    	| [$f60a: rts]

coordinate_transform_four_f60b:
	GET_DP_ADDRESS	0x0f                    	| [$f60b: ldu    $0f]
	move.l		a0,-(a7)
	MOVE_W_A0_IN_D4                         	| [...]
	                        	| [$f60d: lda    #$08]
	move.b	#0x08,(0xC-0xF,a0)                    	| [$f60f: sta    $0c]
	jbsr	compute_coords_f273                            	| [$f611: jsr    $f273]
	move.l		(a7)+,a0                    	| [$f614: stu    $0f]
	MOVE_W_D4_IN_A0                         	| [...]
	rts                                    	| [$f616: rts]

coordinate_transform_eight_f617:
	GET_DP_ADDRESS	0x0f                    	| [$f617: ldu    $0f]
	move.l		a0,-(a7)
	MOVE_W_A0_IN_D4                    	| [...]
	add.w	#0x10,d4                         	| [$f619: leau   $10,u]
											| [$f61c: lda    #$06]
	move.b	#0x06,(0xC-0xF,a0)                    	| [$f61e: sta    $0c]
	jbsr	compute_coords_f386                            	| [$f620: jsr    $f386]
	move.l		(a7)+,a0                    	| [$f623: stu    $0f]
	MOVE_W_D4_IN_A0                         	| [...]
	rts                                    	| [$f625: rts]

enemies_coordinate_transform_f626:
	GET_DP_ADDRESS	0x0f                    	| [$f626: ldu    $0f]
	move.l		a0,-(a7)
	MOVE_W_A0_IN_D4                         	| [...]
	add.w	#0x0108,d4                       	| [$f628: leau   $0108,u]
	                        	| [$f62c: lda    #$08]
	move.b	#0x08,(0xC-0xF,a0)                    	| [$f62e: sta    $0c]
	jbsr	compute_coords_f386                            	| [$f630: jsr    $f386]
	move.l		(a7)+,a0                    	| [$f633: stu    $0f]
	MOVE_W_D4_IN_A0                         	| [...]
	rts                                    	| [$f635: rts]

coordinate_transform_six_f636:
	GET_DP_ADDRESS	0x0f                    	| [$f636: ldu    $0f]
	move.l		a0,-(a7)
	MOVE_W_A0_IN_D4                         	| [...]
	add.w	#0x20,d4                         	| [$f638: leau   $20,u]
												| [$f63b: lda    #$04]
	move.b	#0x04,(0xC-0xF,a0)                    	| [$f63d: sta    $0c]
	jbsr	l_f3f1                            	| [$f63f: jsr    $f3f1]
	move.l		(a7)+,a0                    	| [$f642: stu    $0f]
	MOVE_W_D4_IN_A0                         	| [...]
	rts                                    	| [$f644: rts]

coordinate_transform_seven_f645:
	GET_DP_ADDRESS	0x0f                    	| [$f645: ldu    $0f]
	move.l		a0,-(a7)
	MOVE_W_A0_IN_D4                         	| [...]
	                       	| [$f647: lda    #$04]
	move.b	#0x04,(0xC-0xF,a0)                    	| [$f649: sta    $0c]
	jbsr	l_f3f1                            	| [$f64b: jsr    $f3f1]
	move.l		(a7)+,a0                    	| [$f64e: stu    $0f]
	MOVE_W_D4_IN_A0                         	| [...]
	rts                                    	| [$f650: rts]

coordinate_transform_five_f651:
	GET_DP_ADDRESS	0x0f                    	| [$f651: ldu    $0f]
	move.l		a0,-(a7)
	MOVE_W_A0_IN_D4                         	| [...]
	add.w	#0x10,d4                         	| [$f653: leau   $10,u]
	                        	| [$f656: lda    #$06]
	move.b	#0x06,(0xC-0xF,a0)                    	| [$f658: sta    $0c]
	jbsr	l_f670                            	| [$f65a: jsr    $f670]
	move.l		(a7)+,a0                    	| [$f65d: stu    $0f]
	MOVE_W_D4_IN_A0                         	| [...]
	rts                                    	| [$f65f: rts]

coordinate_transform_zero_f660:
	GET_DP_ADDRESS	0x0f                    	| [$f660: ldu    $0f]
	MOVE_W_A0_IN_D4                         	| [...]
	move.l	a0,-(a7)
	add.w	#0x0108,d4                       	| [$f662: leau   $0108,u]
												| [$f666: lda    #$08]
	move.b	#0x8,(0xC-0xF,a0)                     | [$f668: sta    $0c]
	jbsr	l_f670                            	| [$f66a: jsr    $f670]
	move.l	(a7)+,a0	                    	| [$f66d: stu    $0f]
	MOVE_W_D4_IN_A0                         	| [...]
	rts                                    	| [$f66f: rts]

l_f670:
	GET_U_ADDRESS	0x3                      	| [$f670: lda    $3,u]
	move.b	(a0),d0                         	| [...]
	and.b	#0xc0,d0                         	| [$f672: anda   #$c0]
	GET_DP_ADDRESS	0x12                    	| [$f674: sta    $12]
	move.b	d0,(a0)                         	| [...]
	move.l	a0,a1		| save address
	GET_INDIRECT_ADDRESS	pointer_4211            	| [$f676: inc    [$4211]]
	addq.b	#1,(a0)                         	| [...]
					            	| [$f67a: lda    [$4211]]
	move.b	(a0),d0                         	| [...]
										| [$f67e: adda   $12]
	add.b	(a1),d0                          	| [...]
				                    	| [$f680: sta    $12]
	move.b	d0,(a1)                         	| [...]
	GET_DP_ADDRESS	0x0d                    	| [$f682: stu    $0d]
	MOVE_W_D4_IN_A0_PLUS_1                         	| [...]
	                    	| [$f684: ldb    $0e]
	move.b	(a0),d1                         	| [...]
	lsr.b	#2,d1                            	| [$f686: lsrb]
												| [$f687: lsrb]
	add.b	#0x40,d1                         	| [$f688: addb   #$40]
	GET_INDIRECT_ADDRESS	pointer_4211            	| [$f68a: stb    [$4211]]
	move.b	d1,(a0)                         	| [...]
	addq.w	#0x4,d4                         	| [$f68e: leau   $4,u]
	GET_DP_ADDRESS	0x0c                    	| [$f690: dec    $0c]
	subq.b	#1,(a0)                         	| [...]
	bne	l_f670                             	| [$f692: bne    $f670]
	rts                                    	| [$f694: rts]

update_multiplexed_sprites_f695:
	jbsr	0f
	jra		next_current_ybeam
0:
	GET_DP_ADDRESS	unknown_0b                    	| [$f695: lda    $0b]
	move.b	(a0),d0                         	| [...]
	cmp.b	#0x04,d0                         	| [$f697: cmpa   #$04]
	jcc	l_f6d4                             	| [$f699: jcc    $f6d4]
	move.b	#0x0e,d0                        	| [$f69b: lda    #$0e]
	GET_DP_ADDRESS	number_of_sprites_to_update_total_0a                    	| [$f69d: sta    $0a]
	move.b	d0,(a0)                         	| [...]
	move.w	#sprite_ram_4040,d4             	| [$f69f: ldu    #sprite_ram_4040]
* racing the beam: check if all sprites are above the current beam position
l_f6a2:
	GET_CURRENT_YBEAM                   | [$f6a2: lda    >$0000]
	GET_U_ADDRESS	0x3                      	| [$f6a5: adda   $3,u]
	add.b	(a0),d0                          	| [...]			get sprite Y
	jcs	l_f6b2                             	| [$f6a7: jcs    $f6b2]
	addq.w	#0x4,d4                         	| [$f6a9: leau   $4,u]
l_f6ab:
	cmp.w	#0x4100,d4                       	| [$f6ab: cmpu   #$4100]
	jcs	l_f6b2                             	| [$f6af: jcs    $f6a2]
	rts                                    	| [$f6b1: rts]

l_f6b2:
	GET_DP_ADDRESS	number_of_sprites_to_update_09                    	| [$f6b2: lda    $09]
	move.b	(a0),d0                         	| [...]
	beq	l_f6d5                             	| [$f6b4: beq    $f6d5]
	GET_INDIRECT_ADDRESS	sprite_index_pointer_4200            	| [$f6b6: ldb    [$4200]] 0x6xxx
	moveq	#0,d1
	move.b	(a0),d1                         	| [...]
	add.w	d1,d1                            	| [$f6ba: clra]
	add.w	d1,d1                            	| [$f6bb: aslb]
	                             	| [$f6bc: rola]
	                            	| [$f6bd: aslb]
	                             	| [$f6be: rola]
	
	add.w	#shared_memory_6000,d1           	| [$f6bf: addd   #shared_memory_6000]
	move.w	d1,d2                           	| [$f6c2: tfr    d,x]
	GET_X_ADDRESS	0                        	| [$f6c4: ldd    ,x++]
	addq.w	#4,d2
	move.l	(a0),d0                                 	| [$f6c4: ldd    ,x++]
	GET_U_ADDRESS	0                        	| [$f6c6: std    ,u++]
	addq.w	#4,d4
	* copy sprite data in one go (optimized)
	move.l	d0,(a0)                	| [...]
									| [$f6c8: ldd    ,x]
								| [$f6c8: ldd    ,x]
									| [$f6ca: std    ,u++]
	jbsr	osd_queue_sprite
	
	GET_DP_ADDRESS	sprite_index_pointer_4200_lsb_01                    	| [$f6cc: inc    $01]
	addq.b	#1,(a0)                         	| [...]
	GET_DP_ADDRESS	number_of_sprites_to_update_09                    	| [$f6ce: dec    $09]
	subq.b	#1,(a0)+                         	| [...]
	subq.b	#1,(a0)	                    	| [$f6d0: dec    number_of_sprites_to_update_total_0a]
	                         	| [...]
	jne	l_f6ab                             	| [$f6d2: bne    $f6ab]
l_f6d4:
	rts                                    	| [$f6d4: rts]

l_f6d5:
	GET_DP_ADDRESS	sprite_index_pointer_4200_lsb_01                    	| [$f6d5: lda    $01]
	move.b	(a0),d0                         	| [...]
	and.b	#0xc0,d0                         	| [$f6d7: anda   #$c0]
	sub.b	#0x40,d0                         	| [$f6d9: suba   #$40]
	GET_DP_ADDRESS	sprite_index_pointer_4200_lsb_01                    	| [$f6db: sta    $01]
	move.b	d0,(a0)                         	| [...]
	GET_INDIRECT_ADDRESS	sprite_index_pointer_4200            	| [$f6dd: lda    [$4200]]
	move.b	(a0),d0                         	| [...]
	GET_DP_ADDRESS	number_of_sprites_to_update_09                    	| [$f6e1: sta    $09]
	move.b	d0,(a0)                         	| [...]
	GET_DP_ADDRESS	sprite_index_pointer_4200_lsb_01                    	| [$f6e3: inc    $01]
	addq.b	#1,(a0)                         	| [...]
	GET_DP_ADDRESS	unknown_0b                    	| [$f6e5: inc    $0b]
	addq.b	#1,(a0)                         	| [...]
				                    	| [$f6e7: lda    $0b]
	move.b	(a0),d0                         	| [...]
	cmp.b	#0x04,d0                         	| [$f6e9: cmpa   #$04]
	jcc	l_f6b2                             	| [$f6eb: jcc    $f6b2]
	rts                                    	| [$f6ed: rts]

update_multiplexed_sprites_f6ee:
	jbsr	0f
	jra		next_current_ybeam
0:
	GET_DP_ADDRESS	unknown_0b                    	| [$f6ee: lda    $0b]
	move.b	(a0),d0                         	| [...]
	cmp.b	#0x04,d0                         	| [$f6f0: cmpa   #$04]
	jcc	l_f72d                             	| [$f6f2: jcc    $f72d]
	move.b	#0x0e,d0                        	| [$f6f4: lda    #$0e]
	GET_DP_ADDRESS	number_of_sprites_to_update_total_0a                    	| [$f6f6: sta    $0a]
	move.b	d0,(a0)                         	| [...]
	move.w	#sprite_ram_4040,d4             	| [$f6f8: ldu    #sprite_ram_4040]
* racing the beam again
l_f6fb:
	GET_CURRENT_YBEAM                   | [$f6a2: lda    >$0000]
	GET_U_ADDRESS	0x3                      	| [$f6fe: adda   $3,u]
	add.b	(a0),d0                          	| [...]
	jcs	l_f70b                             	| [$f700: jcs    $f70b]
	addq.w	#0x4,d4                         	| [$f702: leau   $4,u]
l_f704:
	cmp.w	#0x4100,d4                       	| [$f704: cmpu   #$4100]
	jcs	l_f70b                             	| [$f708: jcs    $f6fb]
	rts                                    	| [$f70a: rts]

l_f70b:
	GET_DP_ADDRESS	number_of_sprites_to_update_09                    	| [$f70b: lda    $09]
	move.b	(a0),d0                         	| [...]
	beq	l_f72e                             	| [$f70d: beq    $f72e]
	GET_INDIRECT_ADDRESS	sprite_index_pointer_4200            	| [$f70f: ldb    [$4200]]
	moveq 	#0,d1
	move.b	(a0),d1                         	| [...]
	add.w	d1,d1                            	| [$f713: clra]
	add.w	d1,d1                            	| [$f714: aslb]
	                             	| [$f715: rola]
	                            	| [$f716: aslb]
	                             	| [$f717: rola]
	
	add.w	#shared_memory_6000+0x200,d1        | [$f718: addd   #$6200]
	move.w	d1,d2                           	| [$f71b: tfr    d,x]
	GET_X_ADDRESS	0                        	| [$f71d: ldd    ,x++]
	addq.w	#4,d2
	move.l	(a0),d6                                 	| [$f71d: ldd    ,x++]
	GET_U_ADDRESS	0                        	| [$f71f: std    ,u++]
	addq.w	#4,d4
	* copy both parts of sprite data (optim)
	move.l	d6,(a0)                	| [...]
						| [$f721: ldd    ,x]
						| [$f721: ldd    ,x]
						| [$f723: std    ,u++]
					
					
					
	
	exg		d0,d6
	jbsr	osd_queue_sprite
	exg		d0,d6
	
	GET_DP_ADDRESS	sprite_index_pointer_4200_lsb_01                    	| [$f725: inc    $01]
	addq.b	#1,(a0)                         	| [...]
	GET_DP_ADDRESS	number_of_sprites_to_update_09                    	| [$f727: dec    $09]
	subq.b	#1,(a0)+                         	| [...]
							| [$f729: dec    number_of_sprites_to_update_total_0a]
	subq.b	#1,(a0)                         	| [...]
	bne	l_f704                             	| [$f72b: bne    $f704]
l_f72d:
	rts                                    	| [$f72d: rts]

l_f72e:
	GET_DP_ADDRESS	sprite_index_pointer_4200_lsb_01                    	| [$f72e: lda    $01]
	move.b	(a0),d0                         	| [...]
	and.b	#0xc0,d0                         	| [$f730: anda   #$c0]
	sub.b	#0x40,d0                         	| [$f732: suba   #$40]
									| [$f734: sta    $01]
	move.b	d0,(a0)                         	| [...]
	GET_INDIRECT_ADDRESS	sprite_index_pointer_4200            	| [$f736: lda    [$4200]]
	move.b	(a0),d0                         	| [...]
	GET_DP_ADDRESS	number_of_sprites_to_update_09                    	| [$f73a: sta    $09]
	move.b	d0,(a0)                         	| [...]
	GET_DP_ADDRESS	sprite_index_pointer_4200_lsb_01                    	| [$f73c: inc    $01]
	addq.b	#1,(a0)                         	| [...]
	GET_DP_ADDRESS	unknown_0b                    	| [$f73e: inc    $0b]
	addq.b	#1,(a0)                         	| [...]
				                    	| [$f740: lda    $0b]
	move.b	(a0),d0                         	| [...]
	cmp.b	#0x04,d0                         	| [$f742: cmpa   #$04]
	jcc	l_f70b                             	| [$f744: jcc    $f70b]
	rts                                    	| [$f746: rts]


