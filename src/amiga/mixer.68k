* 0xVER: mixer.asm 3.6 (05.02.24)
*
* mixer.asm
* Audio mixing routines
*  
* For mixer API, see mixer.i and the rest of the mixer documentation.
*
* Note: all mixer configuration is done via mixer_config.i, please do not edit
*       the constants in this file.
*
* Note: code output by this file depends on settings in mixer_config.i
*
* Note: the audio mixer expects samples to be pre-processed such that adding
*       sample values together for all mixer channels can never exceed 8 bit
*       signed limits or overflow from positive to negative (or vice versa).
*
* Note: the audio mixer requires samples to be a multiple of a certain number 
*       of bytes for correct playback. The exact number of bytes depends on 
*       the configuration in mixer_config.i.
*
*       The number of bytes is as follows:
*       *) .ifeq	none of the options below apply, the samples need to be a 
*          multiple of 4 bytes in length
*       *) .ifeq	MIXER_SIZEX32 is set to 1, the samples need to be a multiple of
*          32 bytes in length
*       *) .ifeq	MIXER_SIZEXBUF is set to 1, the samples need to be a multiple of
*          the PAL or NTSC buffer size in length (depending on whether ot not 
*          MIXER_SIZEXBUF_NTSC is 0 or 1)
*       *) .ifeq	MIXER_SIZEX32 and MIXER_SIZEXBUF are set to one, the samples
*          need to be a multiple of the PAL/NTSC buffer size and a multiple of
*          32 bytes in length (depending on whether ot not MIXER_SIZEXBUF_NTSC
*          is 0 or 1)
*
*       The file mixer.i contains the equates mixer_PAL_multiple and 
*       mixer_NTSC_multiple which give the exaxt multiple requirements for
*       samples. Note that in most cases these two will be the same value,
*       only .ifeq	MIXER_SIZEXBUF is set to 1 the number will be different 
*       between these two.
*
* Author: Jeroen Knoester
* Version: 3.6
* Revision: 20240205
*
* Assembled using VASM in Amiga-link mode.
* TAB size = 4 spaces

* Includes (OS includes assume at least NDK 1.3)
	.include "hardware/custom.i"
	.include "hardware/dmabits.i"
	.include "mixer.inc"
	.ifeq	MIXER_CIA_TIMER-1
		.include "hardware/cia.i"
	.endif
	
	.global	MixerGetBufferSize
	.global	MixerSetup
	.global	MixerInstallHandler
	.global	MixerRemoveHandler
	.global	MixerStart
	.global	MixerStop
	.global	MixerVolume
	.global	MixerPlayFX
	.global	MixerPlayChannelFX
	.global	MixerStopFX
	.global	MixerPlaySample
	.global	MixerPlayChannelSample
	.global	MixerGetSampleMinSize
	.global	MixerGetChannelStatus
	.global	MixerEnableCallback
	.global	MixerDisableCallback
	.global	MixerGetPluginsBufferSize
	.global	MixerGetTotalChannelCount
	.global	MixerSetPluginDeferredPtr
	.global	MixerGetChannelBufferSize
	.global	MixerResetCounter
	.global	MixerGetCounter
	
* Constants
mxcustombase		=	0xdff000				| mx prefix to keep one namespace
	.ifeq	MIXER_CIA_TIMER-1
mxciabase			=	0xbfe000				| mx prefix to keep one namespace
	.endif

MIXER_CHAN_INACTIVE	=	0
MIXER_CHAN_ACTIVE	=	1
MIXER_CHAN_LOOP		=	-1

MIXER_STOPPED		= 0
MIXER_RUNNING		= 1

MIXER_AUD_COLOUR	=	0x707
MIXER_IH_COLOUR		=	0xb0b
MIXER_CHUPD_COLOUR	=	0x909
MIXER_PLUGIN_COLOUR	=	0x990
MIXER_OTHER_COLOUR	=	0x099

* Audio channel for use when MIXER_SINGLE is set
	.ifeq	MIXER_SINGLE-1
		.ifeq	mixer_output_aud0-1
mxsinglechan		=	aud0
mxsingledma			= DMAF_AUD0
		.endif
		.ifeq	mixer_output_aud1-1
mxsinglechan		=	aud1
mxsingledma			= DMAF_AUD1
		.endif
		.ifeq	mixer_output_aud2-1
mxsinglechan		=	aud2
mxsingledma			= DMAF_AUD2
		.endif
		.ifeq	mixer_output_aud3-1
mxsinglechan		=	aud3
mxsingledma			= DMAF_AUD3
		.endif
	.endif
	
* Sample/buffer constants
mxslength_word		=	0
	.ifeq	MIXER_68020
		.ifeq	MIXER_WORDSIZED-1
mxslength_word		=	1
		.endif
	.endif

mxsize_x32			= 0
	.ifeq	MIXER_68020
		.ifeq	MIXER_SIZEX32-1
mxsize_x32			= 1
		.endif
	.endif

* Start of code
	.ifeq	MIXER_SECTION-1
			.section code,code
	.endif
	
*-----------------------------------------------------------------------------
* Check various mixer_config.i settings
*-----------------------------------------------------------------------------
mixer_error	=	0

* Check .if	mixer count>=1
	.ifeq	mixer_output_count
mixer_error = 1
		.ifeq	MIXER_NO_ECHO
			
			.error "Error: no mixer output channel has been selected"
		.endif
	.endif
	
* Check .ifeq	software channels between 1 and 4
	.if	mixer_sw_channels<1
mixer_error = 1
		.ifeq	MIXER_NO_ECHO
			
			.error "Error: number of mixed channels out of range (1-4)"
		.endif
	.endif
	
	.if	mixer_sw_channels>4
mixer_error = 1
		.ifeq	MIXER_NO_ECHO
			
			.error "Error: number of mixed channels out of range (1-4)"
		.endif
	.endif

* Check if mixer_config.i only has one mixer type selected
.mxtype_check	=	MIXER_SINGLE+MIXER_MULTI+MIXER_MULTI_PAIRED
	.ifeq	.mxtype_check
mixer_error = 1
		.ifeq	MIXER_NO_ECHO
			
			.error "Error: no mixer type selected in mixer_config.i"
		.endif
	.endif
	.if	.mxtype_check>1
mixer_error = 1
		.ifeq	MIXER_NO_ECHO
			
			.error "Error: more than one mixer type selected in mixer_config.i"
		.endif
	.endif
	
* Check if the single mixer only has one enabled channel
	.if	mixer_output_count>1
		.ifeq	MIXER_SINGLE-1
mixer_error = 1		
			.ifeq	MIXER_NO_ECHO
			
			.error "Error: MIXER_SINGLE only supports one output channel"
			.endif
		.endif
	.endif

* Check .ifeq	the paired mode has both AUD2 and AUD3 selected
.mxchancheck = mixer_output_aud2+mixer_output_aud3
	.if	.mxchancheck<2
		.ifeq	MIXER_MULTI_PAIRED-1
mixer_error = 1
			.ifeq	MIXER_NO_ECHO
			
			.error "Error: MIXER_MULTI_PAIRED requires DMAF_AUD2&3 selected"
			.endif
		.endif
	.endif

	.ifeq	mixer_error		
*-----------------------------------------------------------------------------
* CIA timer start & CIA timer 	.macro	stops (available .ifeq	MIXER_CIA_TIMER-1)
*-----------------------------------------------------------------------------
		.ifeq	MIXER_CIA_TIMER-1
		* Macro: CIAStart
		* 	.macro	This starts the CIA timer to measure mixer performance.
		*
		* Note: MixerInstallHandler should have been called prior to using
		*       	.macro	this.
	.macro	CIAStart
		movem.l	d0/a6,-(sp)					| Stack
		
		* Set up CIA timer A for one shot mode
		lea.l	mxciabase+1,a6
		move.b	ciacra(a6),d0
		and.b	#%11000000,d0				| Keep bits 6&7 as is
		or.b    #%00001000,d0				| Set for one-shot mode
		move.b	d0,ciacra(a6)
        move.b	#%01111111,ciaicr(a6)		| Clear all CIA interrupts
		
		* Set up timer value (low byte first)
		move.b	#0xff,ciatalo(a6)
		move.b	#0xff,ciatahi(a6)
		
		movem.l	(sp)+,d0/a6					| Stack
			.endm
		
		* Macro: CIAStop
		* 	.macro	This ends the CIA timer and store the measured results.
		*
		* Note: MixerInstallHandler should have been called prior to using
		*       	.macro	this.
	.macro	CIAStop
		movem.l	d0/d1/a6,-(sp)				| Stack
		
		* Stop timer & fetch result
		lea.l	mxciabase+1,a6
		bclr	#0,ciacra(a6)
		moveq	#0,d0
		moveq	#0,d1
		move.b	ciatalo(a6),d0
		move.b	ciatahi(a6),d1
		lsl.w	#8,d1
		or.w	d1,d0
		
		* Store result
		lea.l	mixer_ticks_last(pc),a6
		move.w	d0,(a6)						| Store last result

		* Compare result with best stored result
		cmp.w	2(a6),d0
		bls.s	.\@_not_best
		
		move.w	d0,2(a6)					| Store best result
		
.\@_not_best
		* Compare result with worst stored result
		cmp.w	4(a6),d0
		bcc.s	.\@_not_worst
		
		move.w	d0,4(a6)					| Store worst result
		
.\@_not_worst

		* Update average list
		lea.l	mixer_ticks_storage_off(pc),a6
		move.w	(a6),d1
		move.w	d0,2(a6,d1.w)				| Store in buffer
		addq.w	#2,d1

		cmp.w	#256,d1
		ble.s	.\@_no_avg_reset
		
		* Reset average counter
		moveq	#0,d1
		
.\@_no_avg_reset
		* Write to average buffer
		move.w	d1,(a6)
		
		movem.l	(sp)+,d0/d1/a6				| Stack
			.endm
		.endif

*-----------------------------------------------------------------------------
* Setup routines
*-----------------------------------------------------------------------------

		* Routine: MixerSetup
		* This routine sets up the data structures and buffers used by the 
		* mixer.
		*
		* Note: no error checking is done, .ifeq	the values in mixer_config.i are
		*       invalid or the values passed in D0 & A0 are incorrect, the
		*       outcome of this routine is undefined.
		*
		* Note: the mixer defaults to the maximum hardware volume of 64, in 
		*       part to compensate for the lower maximum volume mixed samples
		*       have (due to the lower maximum amplitude value of the 
		*       individual samples).
		*
		* D0 - Set to MIX_PAL when running on a PAL system,
		*      set MIX_NTSC when running on a NTSC system
		* D1 - Set to maximum plugin data structure length. For the built-in
		*      plugins, this value can be obtained by either using the 
		*      constant mxplg_max_data_size from plugins.i, or by calling the
		*      plugin support routine MixerPluginGetMaxDataSize.
		*
		*      .ifeq	custom plugins are in use, pass either the value above, or
		*      the maximum plugin data length for the custom plugins .ifeq	this
		*      is larger.
		* A0 - Pointer to a block of Chip Memory to use for mixer buffers.
		*      This block needs to be mixer_buffer_size bytes in size.
		* A1 - Pointer to a block of memory (of any type) to use for mixer
		*      plugin buffers. This block needs to be mixer_plugin_buffer_size
		*      bytes in size. Only needed .ifeq	MIXER_ENABLE_PLUGINS is set to 1.
		* A2 - Pointer to a block of memory (of any type) to use for mixer
		*      plugin data structures. This block needs to have a size in
		*      bytes of the value passed in D1, multiplied by
		*      mixer_total_channels.
		*
		*      Note: on 68020+, the blocks of memory in A0, A1 & A2 should be
		*            longword aligned for optimal performance. On 68000, the
		*		     blocks must be at least aligned on a word boundary.
MixerSetup:
		movem.l	d0/d2-d7/a0-a4,-(sp)		| Stack

		* Fetch mixer structure
		lea.l	mixer(pc),a3
		
		* Store PAL/NTSC flag
		move.w	d0,mx_vidsys(a3)

		* Set buffer offset value based on PAL/NTSC flag
		cmp.w	#MIX_NTSC,d0
		beq.s	loc_mixer_ntsc
		
loc_mixer_pal:
		move.l	#mixer_PAL_buffer_size,d0
		move.w	#mixer_PAL_period,d3
		bra.s	fill_mixer_struct
		
loc_mixer_ntsc:
		move.l	#mixer_NTSC_buffer_size,d0
		move.w	#mixer_NTSC_period,d3
		
		* Fill mixer structure
fill_mixer_struct:
		moveq	#0,d4
		move.w	#MIXER_STOPPED,mx_status(a3)
		move.w	#64,mx_volume(a3)
		move.w	d3,mx_hw_period(a3)
		move.w	#mixer_output_channels,d6
		move.w	d6,mx_hw_channels(a3)
		.ifeq	MIXER_ENABLE_CALLBACK-1
			move.l	d4,mx_callback_ptr(a3)
		.endif
		move.w	d0,mx_buffer_size(a3)
		move.w	d0,d7
		asr.w	#1,d7
		move.w	d7,mx_buffer_size_w(a3)
		move.l	a0,mx_empty_buffer(a3)
		bsr		MixerClearBuffer		| Clear the empty buffer
		.ifeq	MIXER_MULTI_PAIRED-1
			and.w	#0x7,d6
		.endif
		asl.w	#7,d6
		move.w	d6,mx_irq_bits(a3)
		
		* Fill mixer entry structure(s)
		.ifeq	MIXER_SINGLE-1
			moveq	#1-1,d7
			moveq	#1,d6
			moveq	#mxsingledma,d2
		.else
			moveq	#4-1,d7
			moveq	#mixer_output_channels,d6
			moveq	#DMAF_AUD0,d2
		.endif
		.ifeq	MIXER_MULTI_PAIRED-1
			and.w	#0x7,d6
		.endif
		lea.l	mx_mixer_entries(a3),a3
		
		* Loop over entries
loc_mixer_entry_lp:
		* Check .ifeq	current HW channel is active
		btst	#0,d6
		beq		loc_mixer_entry_lp_end
		
		.ifeq	MIXER_MULTI_PAIRED-1
			* Clear active bit
			move.w	#0,mxe_active(a3)
		.endif

		* Set up for channel loop
		moveq	#mixer_sw_channels-1,d5
		move.w	#MIX_CH0,d3
		lea.l	mxe_channels(a3),a4
		
		* Loop over mixer entry channels
loc_mixer_channel_lp:
		.ifeq	mxslength_word-1
			move.w	d4,mch_remaining_length
			move.w	d4,mch_length(a4)
			move.w	d4,mch_loop_length(a4)
		.else
			move.l	d4,mch_remaining_length(a4)
			move.l	d4,mch_length(a4)
			move.l	d4,mch_loop_length(a4)
		.endif
		move.l	d4,mch_sample_ptr(a4)
		move.l	d4,mch_loop_ptr(a4)
		.ifeq	MIXER_ENABLE_CALLBACK-1
			move.l	d4,mch_orig_sam_ptr(a4)
		.endif
		.ifeq	MIXER_ENABLE_PLUGINS-1
			move.l	d4,mch_plugin_ptr(a4)
			move.l	d4,mch_plugin_deferred_ptr(a4)
			move.l	a2,mch_plugin_data_ptr(a4)
			move.l	a1,mch_plugin_output_buffer(a4)
			move.w	d4,mch_plugin_type(a4)
			movem.l	d0/a0,-(sp)
			move.l	a1,a0
			bsr		MixerClearBuffer
			move.w	d1,d0
			move.l	a2,a0
			bsr		MixerClearPluginData
			movem.l	(sp)+,d0/a0
			lea.l	0(a1,d0.w),a1
			lea.l	0(a2,d1.w),a2
		.endif
		or.w	d2,d3
		move.w	d3,mch_channel_id(a4)
		move.w	d4,mch_status(a4)
		move.w	d4,mch_priority(a4)
		move.w	d4,mch_age(a4)
		and.w	#0xf0,d3
		lsl.w	#1,d3
		lea.l	mch_SIZEOF(a4),a4
		dbra	d5,loc_mixer_channel_lp

		* Fill mixer entry current channel & sample pointers
		moveq	#4-1,d5
		lea.l	mxe_active_channels(a3),a4
		
loc_mixer_pointers_lp:
		move.l	d4,16(a4)
		move.l	d4,(a4)+
		dbra	d5,loc_mixer_pointers_lp
		
		* Fill mixer entry buffer pointers & clear buffers
		lea.l	mxe_buffers(a3),a4
		lea.l	0(a0,d0.w),a0
		move.l	a0,(a4)+
		bsr		MixerClearBuffer
		lea.l	0(a0,d0.w),a0
		move.l	a0,(a4)+
		bsr		MixerClearBuffer

loc_mixer_entry_lp_end:
		asr.w	#1,d6
		asl.w	#1,d2
		lea.l	mxe_SIZEOF(a3),a3
		dbra	d7,loc_mixer_entry_lp

		movem.l	(sp)+,d0/d2-d7/a0-a4		| Stack
		rts

		* Routine: MixerInstallHandler
		* This routine sets up the required audio interrupt for the mixer.
		*
		* Note: MixerSetup must have been called prior to calling this 
		*       routine.
		* Note: .ifeq	MIXER_CIA_TIMER is set to 1, this routine also saves the
		*       CIA state to be able to restore it later.
		*
		* D0 - 0: save old interrupt vector
		*      1: do not save old interrupt vector
		* A0 - Pointer to VBR
		*
		*      Note: on systems without VBR (i.e. 68000 based systems), A0 has
		*      to be set to 0.
MixerInstallHandler:
		movem.l	d1/a1/a6,-(sp)				| Stack
		
		.ifeq	MIXER_CIA_TIMER-1
			move.w	d0,-(sp)				| Stack
			
			* Save CIA values
			lea.l	mxciabase+1,a6			| CIA A
			lea.l	mixer_stored_cia(pc),a1

			move.b	ciacra(a6),d0
			move.b	ciaicr(a6),d1
			move.b	d0,(a1)					| Store CIA control value
			move.b	d1,1(a1)				| Store CIA IC value
			
			move.w	(sp)+,d0				| Stack
		.endif
		
		* Fetch custombase
		lea.l	mxcustombase,a6
		
		* Store the VBR value
		lea.l	mixer_stored_vbr(pc),a1
		move.l	a0,(a1)+
		
		* Save interrupt vector if needed
		tst.w	d0
		bne		0f
		move.l	0x70(a0),(a1)+

		* Save any audio interrupt bits set
		move.w	intenar(a6),d1
		and.w	#0x780,d1   | #%11110000000,d1			| Audio = bits 7-10
		or.w	#0x8000,d1
		move.w	d1,(a1)+
		
0:
		* Disable all audio interrupts
		move.w	#0x780,d1			| Audio = bits 7-10
		move.w	d1,intena(a6)				| Disable audio interrupts
		move.w	d1,intreq(a6)				| Clear any pending interrupts
		move.w	d1,intreq(a6)				| Twice for A4000
		
		* Set audio interrupt handler
		lea.l	MixerIRQHandler(pc),a1		| Interrupt handler
		move.l	a1,0x70(a0)					| 0x70 is vector 4 / audio
		
		* Calculate audio interrupt bit for correct channel and store result
		lea.l	mixer(pc),a1				| Fetch mixer structure
		move.w	#mixer_output_channels,d1	| Load audio channel bit(s)
		lsl.w	#7,d1						| Shift by 7 to get interrupt bit
		move.w	d1,mx_irq_bits(a1)			| Store result
		
		* Set up audio interrupt
		or.w	#0xc000,d1					| Prep INTENA setup
		move.w	d1,intena(a6)				| Set INTENA value
		tst.w	dmaconr(a6)					| Delay for A4000
		
		* Update mixer status
		move.w	#MIXER_RUNNING,mx_status(a1)
		
		movem.l	(sp)+,d1/a1/a6				| Stack
		rts

		* Routine: MixerRemoveHandler
		* This routine disables & removes the audio interrupt.
		* It also restores the old handler if previously stored.
		*
		* Note: MixerSetup & MixerInstallHandler must have been called prior to calling
		*       this routine.
		* Note: .ifeq	MIXER_CIA_TIMER is set to 1, this routine also restores the
		*       saved CIA state.
		* Note: .ifeq	MIXER_CIA_TIMER & MIXER_CIA_KBOARD_RES are set to 1, this
		*       routine also restores the keyboard for AmigaOS use. Note that
		*       in this case, the MixerRemoveHandler routine should be called
		*       shortly before returning to the OS to prevent CIA timer 
		*       underflows.
MixerRemoveHandler:
		movem.l	d0/a0/a1/a6,-(sp)			| Stack
		
		* Fetch custom base
		lea.l	mxcustombase,a6

		* Disable all audio interrupts
		move.w	#0x780,d0			| Audio = bits 7-10
		move.w	d0,intena(a6)				| Disable audio interrupts
		move.w	d0,intreq(a6)				| Clear any pending interrupts
		move.w	d0,intreq(a6)				| Twice for A4000

		* Restore interrupt vector (.ifeq	set)
		lea.l	mixer_stored_vbr(pc),a1
		move.l	(a1)+,a0					| Get VBR
		move.l	(a1)+,d0					| Get handler
		beq		0f

		* Restore interrupt vector
		move.l	d0,0x70(a0)					| Vector 4
		
		* Restore INTENA value
		move.w	(a1)+,intena(a6)			| Set old intena values
		tst.w	dmaconr(a6)					| Delay for A4000
		
0:
		* Update mixer status
		lea.l	mixer(pc),a1
		move.w	#MIXER_STOPPED,mx_status(a1)

		.ifeq	MIXER_CIA_TIMER-1
			* Restore CIA values
			lea.l	mxciabase+1,a6			| CIA A
			lea.l	mixer_stored_cia(pc),a1
			move.b	(a1),ciacra(a6)			| Restore CIA A control value
			move.b	1(a1),ciaicr(a6)		| Restore CIA A IC value

			.ifeq	MIXER_CIA_KBOARD_RES-1
				* Remaining code to restore keyboard
				move.b	#0xff,ciatblo(a6)	| TB=0xffff
				move.b	#0xff,ciatbhi(a6)
				* Re-enable CIA-A interrupts for AmigaOS
				move.b	#0x8f,ciaicr(a6)
			.endif
		.endif
		movem.l	(sp)+,d0/a0/a1/a6			| Stack
		rts

		* Routine: MixerStart
		* This routine enables playback of mixed samples. Initial playback is
		* silence.
		*
		* Note: MixerSetup & MixerInstallHandler must have been called prior
		*       to calling this routine.
		* Note: .ifeq	MIXER_CIA_TIMER is set to 1, this routine also clears the
		*       stored CIA timer results.
MixerStart:
		movem.l	d0/d1/d7/a0/a6,-(sp)		| Stack

		.ifeq	MIXER_CIA_TIMER-1
			* Clear stored CIA timing results
			lea.l	mixer_ticks_last(pc),a6
			clr.w	(a6)+
			clr.w	(a6)+
			move.w	#0xffff,(a6)
		.endif
		
		* Fetch custombase
		lea.l	mxcustombase,a6
		
		* Enable audio interrupts for all valid channels
		lea.l	mixer(pc),a0
		move.w	mx_irq_bits(a0),d0			| Fetch IRQ bits
		or.w	#0xc000,d0					| Prep INTENA setup
		move.w	d0,intena(a6)				| Set INTENA value
		tst.w	dmaconr(a6)					| Delay for A4000
		
		.ifeq	MIXER_SINGLE-1
			move.w	#mxsinglechan,d1
		.else
			* Play silence on all selected channels
			move.w	#mixer_output_channels,d0
			move.w	#aud,d1
			moveq	#4-1,d7
			
			* Loop over all channels
.lp			btst	#0,d0
			beq		next_channel1
		.endif
		
		* Play silence
		bsr		MixerPlaySilence

		.ifeq	MIXER_SINGLE
		* Go to next channel
next_channel1:
			asr.w	#1,d0
			add.w	#ac_SIZEOF,d1
			dbra	d7,.lp
		.endif
		
		movem.l	(sp)+,d0/d1/d7/a0/a6		| Stack
		rts

		* Routine: MixerStop
		* This routine disables playback of mixed samples.
		*
		* Note: MixerSetup, MixerInstallHandler & MixerStart must have been called
		*       before calling this routine.
MixerStop:
		movem.l	d6/d7/a0/a6,-(sp)				| Stack
		
		* Fetch custombase
		lea.l	mxcustombase,a6
		
		* Fetch mixer, irq bits & HW channels
		lea.l	mixer(pc),a0
		move.w	mx_irq_bits(a0),d7
		move.w	mx_hw_channels(a0),d6
		
		* Disable audio interrupt(s)
		move.w	d7,intena(a6)					| Disable audio interrupts
		move.w	d7,intreq(a6)					| Clear any pending interrupts
		move.w	d7,intreq(a6)					| Twice for A4000
		
		
		.ifeq	MIXER_SINGLE-1
			move.w	#mxsinglechan,d1
		.else
			* Play silence on all selected channels
			move.w	#mixer_output_channels,d0
			move.w	#aud,d1
			moveq	#4-1,d7
			
			* Loop over all channels
lp:
			btst	#0,d0
			beq		next_channel
		.endif
		
		* Play silence & set volume to zero.
		bsr		MixerPlaySilence
		move.w	#0,ac_vol(a6,d1.w)

		.ifeq	MIXER_SINGLE
		* Go to next channel
next_channel:
			asr.w	#1,d0
			add.w	#ac_SIZEOF,d1
			dbra	d7,lp
		.endif
		
		* Disable audio DMA for the mixing channel(s)
		move.w	d6,dmacon(a6)
		
		* Fetch mixer entries
		lea.l	mx_mixer_entries(a0),a0
		
		* Loop over all mixer entries
		.ifeq	MIXER_SINGLE-1
			moveq	#1-1,d7
		.else
			moveq	#4-1,d7
		.endif
enlp:
	lea.l	mxe_channels(a0),a6
		
		* Deactivate all mixer channels per entry
		moveq	#4-1,d6
chlp:
		move.w	#MIXER_CHAN_INACTIVE,mch_status(a6)
		lea.l	mch_SIZEOF(a6),a6
		dbra	d6,chlp
		
		* Loop back
		lea.l	mxe_SIZEOF(a0),a0
		dbra	d7,enlp
		
		movem.l	(sp)+,d6/d7/a0/a6				| Stack
		rts
		
		* Routine: MixerVolume
		* This routine sets the hardware volume used by the mixer hardware
		* channels during playback.
		*
		* Note: when running MixerSetup, volume is set to the hardware maximum
		*       of 64 by default.
		*
		* D0 - desired volume (0-64)
MixerVolume:
		move.l	a0,-(sp)					| Stack

		* Fetch mixer & set volume
		lea.l	mixer(pc),a0
		move.w	d0,mx_volume(a0)

		move.l	(sp)+,a0					| Stack
		rts
		
*-----------------------------------------------------------------------------
* SFX 	.macro	playbacks
*-----------------------------------------------------------------------------

		* Macro: MixChkChan
		* 	.macro	This forms the an unrolled loop entry for checking .ifeq	a mixer
		* channel is free for use by the requested sample, taking into account
		* priority and age.
		*
		* \1 channel number (or 0 in case of MIXER_68020)
	.macro	MixChkChan	arg
		* Check .ifeq	the channel can be used
		.ifeq	MIXER_68020-1
			swap	d3
			move.w	mch_status(a1),d0
			smi		d3
			or.b	d3,d0
			swap	d3
			addq.w	#1,d0
			add.w	d0,d0
			add.w	d0,d0
			jmp		stjmp_table\arg(pc,d0.w)
		.else
			swap	d0
			move.w	mch_status(a1),d7
			smi		d0
			or.b	d0,d7
			swap	d0
			addq.w	#1,d7
			add.w	d7,d7
			add.w	d7,d7
			jmp		stjmp_table\arg(pc,d7.w)
		.endif

stjmp_table\arg:
		* Jump table for the different statusses (free, in use, looping)
		jmp		.not_free\arg(pc)
		jmp		.play_fx\arg(pc)
		jmp		.check_priority\arg(pc)

.play_fx\arg:
		* This channel is free, play the sample here
		.ifeq	MIXER_68020-1
			moveq	#0,d6
			bset	d7,d6					| Best channel found
		.else
			move.w	#MIX_CH\arg,d6			| Best channel found
		.endif
		bra		.found
		
.check_priority\arg:
		* Check based on priority
		* Check if the priority of the new sample is equal or higher than the
		* current channel.
		cmp.w	mch_priority(a1),d2
		blt.s	.not_free\arg

		* Check .ifeq	the priority of the current channel is lower than the best
		* found priority so far.
		cmp.w	mch_priority(a1),d4
		bgt.s	.new_best_chan\arg
		
		* Check .ifeq	the age of the current channel is higher than the best age
		* found so far.
		cmp.w	mch_age(a1),d5
		bhi.s	.not_free\arg
		
.new_best_chan\arg:
		* Set current channel as best found so far
		move.w	mch_priority(a1),d4			| Best priority found
		move.w	mch_age(a1),d5				| Reset best age found
		.ifeq	\arg-1
			moveq	#0,d6
			bset	d7,d6					| Best channel found
		.else
			move.w	#MIX_CH\arg,d6			| Best channel found
		.endif
		move.l	a1,a2						| Best channel found pointer

.not_free\arg:
		* This channel is not free, continue with the next channel.
		lea.l	mch_SIZEOF(a1),a1
				.endm


*-----------------------------------------------------------------------------
* SFX playback routines
*-----------------------------------------------------------------------------

		* Routine: MixerFetchEntry
		* This routine forms the common code for fetching the correct mixer
		* entry. Used in MixPlaySam/MixPlaySamCh.
MixerFetchEntry:
		* Fetch mixer & first entry
		lea.l	mixer+mx_mixer_entries(pc),a1
		
		* Multi mixer path
		.ifeq	MIXER_SINGLE
			* Jump to selected entry
			move.w	d0,d4
			and.w	#0xf,d4
			add.w	d4,d4
			add.w	d4,d4
			jmp		enjmp_table(pc,d4.w)
			
			* Jump table
			* The empty space included in the table is required for the 
			* conversion between entry bit and entry number.
enjmp_table
			nop
			nop
			jmp	en0(pc)
			jmp	en1(pc)
			.long	0
			jmp	en2(pc)
			.long	0,0,0
			
en3:		lea.l	mxe_SIZEOF(a1),a1
en2:		lea.l	mxe_SIZEOF(a1),a1
en1:		lea.l	mxe_SIZEOF(a1),a1
en0:	
		.endif

		* Select first channel
		lea.l	mxe_channels(a1),a1
		rts

		* Routine: MixerChannelWrite
		* This routine forms the common code for writing the effect structure
		* into a mixer channel.
MixerChannelWrite:
		* Writes to the channel must be atomic (i.e. can't be interrupted by
		* the audio mixer to prevent failures in playback)

		* Test .ifeq	the mixer interrupts are running
		move.w	mixer+mx_status(pc),d7
		beq.s	0f
		
		* Disable audio interrupts
		lea.l	mxcustombase,a6
		move.w	mixer+mx_irq_bits(pc),d7		| Fetch audio bits
		and.w	#0x7fff,d7						| Mask out SET/CLR bit
		move.w	d7,intena(a6)					| Disable audio interrupts
		tst.w	dmaconr(a6)						| Wait for A4000		
0:

		* Start of atomic part
write_plugin:
		.ifeq	MIXER_ENABLE_PLUGINS-1
			* Set pointer to plugin
			move.l	d7,-(sp)					| Stack
			moveq	#0,d7
			move.l	d7,mch_plugin_ptr(a1)
			move.l	d7,mch_plugin_deferred_ptr(a1)
			move.l	mfx_plugin_ptr(a0),d7
			beq.s	.no_plugin

			* Initialise plugin
			movem.l	a1/a2/a6,-(sp)				| Stack
			
			move.l	d7,a6						| Plugin in A6
			move.w	mpl_plugin_type(a6),mch_plugin_type(a1)
			move.l	mpl_plugin_ptr(a6),mch_plugin_ptr(a1)
			move.l	mch_plugin_data_ptr(a1),a2	| Data in A2
			move.l	mpl_init_data_ptr(a6),a1	| Init data in A1

			move.l	mpl_init_ptr(a6),a6
			.ifeq	MIXER_C_DEFS-1
				movem.l	d0/a0,-(sp)
				jsr		(a6)					| Call init
				movem.l	(sp)+,d0/a0
			.else
				jsr		(a6)					| Call init
			.endif
			move.l	mfx_length(a0),d1			| Get correct length
	
			movem.l	(sp)+,a1/a2/a6				| Stack
			
.no_plugin:
			move.l	(sp)+,d7					| Stack
		.endif

		.ifeq	mxslength_word-1
			move.w	d1,mch_length(a1)			| Set length
			move.w	d1,mch_remaining_length(a1)	| Set remaining length
		.else
			move.l	d1,mch_length(a1)			| Set length
			move.l	d1,mch_remaining_length(a1)	| Set remaining length
		.endif
		move.w	d2,mch_priority(a1)			| Set priority
		move.w	#0,mch_age(a1)				| Set age

		move.l	mfx_sample_ptr(a0),mch_sample_ptr(a1)| Set sample pointer
		.ifeq	MIXER_ENABLE_CALLBACK-1
			move.l	mfx_sample_ptr(a0),mch_orig_sam_ptr(a1)
		.endif

		tst.w	mfx_loop(a0)
		bmi.s	write_loop_ptr				| Check for looping sample

		* Not a loop, use empty buffer		
		move.l	mixer+mx_empty_buffer(pc),mch_loop_ptr(a1)
		.ifeq	mxslength_word-1
			move.w	d1,mch_loop_length(a1)
		.else
			move.l	d1,mch_loop_length(a1)
		.endif
		jra	.write_status
		
write_loop_ptr:
		cmp.w	#MIX_FX_LOOP_OFFSET,mfx_loop(a0)
		jeq	.write_loop_offset_ptr
			
		move.l	mfx_sample_ptr(a0),mch_loop_ptr(a1)	| Set sample pointer

		.ifeq	mxslength_word-1
			move.w	d1,mch_loop_length(a1)
		.else
			move.l	d1,mch_loop_length(a1)
		.endif
		jra	.write_status
			
.write_loop_offset_ptr:
		* Force loop offset to be in bounds of the sample here
		move.l	d0,-(sp)
		.ifeq	mxslength_word-1
			moveq	#0,d7
			move.w	mfx_loop_offset+2(a0),d7
		.else
			move.l	mfx_loop_offset(a0),d7
			bpl.s	loop_offset_larger_fx

			* Loop offset must be zero or higher
			moveq	#0,d7
		.endif
			
loop_offset_larger_fx:
		.ifeq	mxslength_word-1
			moveq	#0,d0
			move.w	d1,d0
		.else
			move.l	d1,d0
		.endif
		
		.ifeq	mxsize_x32-1
			and.w	#0xffe0,d7		| Limit to multiple of 32 bytes
		.else
			and.w	#0xfffc,d7		| Limit to multiple of  4 bytes
		.endif
		
		sub.l	d7,d0
		jgt		.loop_offset_in_bounds_fx
		
		move.l	d0,d7
		subq.l	#4,d7				| Loop offset now in range
		moveq	#4,d0				| Length in range

.loop_offset_in_bounds_fx:
		.ifeq	mxslength_word-1
			move.w	d0,mch_loop_length(a1)
		.else
			move.l	d0,mch_loop_length(a1)
		.endif
		move.l	(sp)+,d0

		add.l	mfx_sample_ptr(a0),d7
		move.l	d7,mch_loop_ptr(a1)

.write_status:
		move.w	mfx_loop(a0),mch_status(a1)	| Set status

		* Test .ifeq	the mixer interrupts are running
		move.w	mixer+mx_status(pc),d7
		beq.s	irq_enabled
		
		* Re-enable audio interrupts
		move.w	mixer+mx_irq_bits(pc),d7
		or.w	#0x8000,d7					| Set the SET/CLR bit
		move.w	d7,intena(a6)				| Enable audio interrupts
irq_enabled:

		* End of atomic part
		rts

		* Routine: MixerPlaySample
		* This routine plays the given sample on the given hardware channel, 
		* selecting the best possible fitting mixer channel available. 
		* Priority is taken into account.
		*
		* Fails if no applicable mixer channel is free.
		*
		* Note: this routine does not check if the HW channel selected is 
		*       available to the mixer, if an unused HW channel is 
		*       selected, no sample will be played back. This only applies .ifeq	*       MIXER_MULTI=1 or  MIXER_MULTI_PAIRED=1.
		* Note: once playing, looping samples can only be ended by calling
		*       MixerStopFX. Until this happens, a looping sample will occupy
		*       a mixer channel forever, regardless of the priority of any
		*       incoming sample playback requests.
		*
		*       Keep in mind that the initial playback request for a looping
		*       sample will follow priorities as normal to determine .ifeq	it can
		*       start playing.
		*
		* A0 - Pointer to sample data
		* D0 - Hardware channel (f.ex. DMAF_AUD0)
		*      Note: .ifeq	MIXER_SINGLE-1, hardware channel selection is ignored.
		*      Note: .ifeq	MIXER_MULTI_PAIRED-1, DMAF_AUD3 is not a valid
		*            channel.
		*      Note: Only one HW channel can be selected at a time.
		* D1 - Length of sample in bytes
		* D2 - Priority (signed, higher number=higher priority)
		* D3 - Loop indicator (MIX_FX_ONCE, MIX_FX_LOOP or MIX_FX_LOOP_OFFSET)
		* D4 - Loop offset (used when MIX_FX_LOOP_OFFSET is set)
		*
		* Returns
		* D0 - Either:
		*      *) -1, .ifeq	the sample can't be played (f.ex. due to priority)
		*      *) Hardware/mixer channel combination the sample will be played
		*         on. (f.ex. DMAF_AUD0|MIX_CH2)
MixerPlaySample:
		.ifeq	MIXER_TIMING_BARS-1
			move.w	#MIXER_OTHER_COLOUR,0xdff180
		.endif
		
		move.l	a1,-(sp)					| Stack

		move.l	a0,a1
		lea.l	mixer_fx_struct(pc),a0		| Get FX struct
		
		* Fill FX struct
		move.l	a1,mfx_sample_ptr(a0)
		.ifeq	mxslength_word-1
			move.l	d7,-(sp)
			moveq	#0,d7
			move.w	d1,d7
			move.l	d7,mfx_length(a0)
			move.w	d4,d7
			move.l	d7,mfx_loop_offset(a0)
			move.l	(sp)+,d7
		.else
			move.l	d1,mfx_length(a0)
			move.l	d4,mfx_loop_offset(a0)			
		.endif
		move.w	d3,mfx_loop(a0)
		move.w	d2,mfx_priority(a0)
		clr.l	mfx_plugin_ptr(a0)
		
		* Call MixerPlayFX
		bsr		MixerPlayFX
		
		move.l	a1,a0
		move.l	(sp)+,a1					| Stack

		.ifeq	MIXER_TIMING_BARS-1
			move.w	#MIXER_DEFAULT_COLOUR,0xdff180
			tst.w	d0						| Restore condition code
		.endif
		rts

		* Routine: MixerPlayChannelSample
		* This routine plays the given sample on the given hardware/mixer
		* channel combination. Priority and channel availability are taken
		* into account.
		*
		* Fails .ifeq	the selected hardware/mixer channel combination is not 
		* free.
		*
		* Note: this routine does not check .ifeq	the HW channel selected is 
		*       available to the mixer, .ifeq	an unused HW channel is 
		*       selected, no sample will be played back. This only applies .ifeq	*       MIXER_MULTI=1 or  MIXER_MULTI_PAIRED=1.
		* Note: this routine does not check .ifeq	the mixer is running with 
		*       enough mixed channels for the required mixer channel to be 
		*       in use. .ifeq	the mixer channel is not in use, no sample will be
		*       played back.
		* Note: once playing, looping samples can only be ended by calling
		*       MixerStopFX. Until this happens, a looping sample will occupy
		*       a mixer channel forever, regardless of the priority of any
		*       incoming sample playback requests.
		*
		*       Keep in mind that the initial playback request for a looping
		*       sample will follow priorities as normal to determine .ifeq	it can
		*       start playing.
		*
		* A0 - Pointer to sample data
		* D0 - Hardware channel/mixer channel (f.ex. DMAF_AUD0|MIX_CH1)
		*      Supports setting exactly one mixer software channel.
		*
		*      Note: .ifeq	MIXER_SINGLE-1, hardware channel selection is ignored.
		*      Note: .ifeq	MIXER_MULTI_PAIRED-1, DMAF_AUD3 is not a valid
		*            channel.
		*      Note: Only one HW channel can be selected at a time.
		* D1 - Length of sample in bytes
		* D2 - Priority (signed, higher number=higher priority)
		* D3 - Loop indicator (MIX_FX_ONCE, MIX_FX_LOOP or MIX_FX_LOOP_OFFSET)
		* D4 - Loop offset (used when MIX_FX_LOOP_OFFSET is set)
		*
		* Returns
		* D0 - Either:
		*      *) -1, .ifeq	the sample can't be played (f.ex. due to priority)
		*      *) Hardware/mixer channel combination the sample will be played
		*         on. (f.ex. DMAF_AUD0|MIX_CH1)
MixerPlayChannelSample:
		.ifeq	MIXER_TIMING_BARS-1
			move.w	#MIXER_OTHER_COLOUR,0xdff180
		.endif

		move.l	a1,-(sp)			| Stack
		move.l	a0,a1
		lea.l	mixer_fx_struct(pc),a0		| Get FX struct
		
		* Fill FX struct
		move.l	a1,mfx_sample_ptr(a0)
		.ifeq	mxslength_word-1
			move.l	d7,-(sp)
			moveq	#0,d7
			move.w	d1,d7
			move.l	d7,mfx_length(a0)
			move.w	d4,d7
			move.l	d7,mfx_loop_offset(a0)
			move.l	(sp)+,d7
		.else
			move.l	d1,mfx_length(a0)
			move.l	d4,mfx_loop_offset(a0)			
		.endif
		move.w	d3,mfx_loop(a0)
		move.w	d2,mfx_priority(a0)
		clr.l	mfx_plugin_ptr(a0)
		
		* Call MixerPlayChannelFX
		bsr		MixerPlayChannelFX
		
		move.l	a1,a0
		move.l	(sp)+,a1			| Stack
		
		.ifeq	MIXER_TIMING_BARS-1
			move.w	#MIXER_DEFAULT_COLOUR,0xdff180
			tst.w	d0						| Restore condition code
		.endif
		rts
		
		* Routine: MixerPlayFX
		* This routine plays the given sample on the given hardware 
		* channel, selecting the best possible fitting mixer channel
		* available. Priority is taken into account.
		*
		* Fails quietly if no applicable mixer channel is free.
		*
		* Note: this routine does not check if the HW channel selected is 
		*       available to the mixer, if an unused HW channel is 
		*       selected, no sample will be played back. This only applies if MIXER_MULTI=1 or  MIXER_MULTI_PAIRED=1.
		* Note: once playing, looping FX can only be ended by calling
		*       MixerStopFX. Until this happens, a looping FX will occupy a
		*       mixer channel forever, regardless of the priority of any
		*       incoming FX playback requests.
		*
		*       Keep in mind that the initial playback request for a looping
		*       FX will follow priorities as normal to determine .ifeq	it can 
		*       start playing.
		*
		* A0 - Pointer to MXEffect structure for the effect to play
		* D0 - Hardware channel (f.ex. DMAF_AUD0)
		*      Note: .ifeq	MIXER_SINGLE-1, hardware channel selection is ignored.
		*      Note: .ifeq	MIXER_MULTI_PAIRED-1, DMAF_AUD3 is not a valid
		*            channel.
		*      Note: Only one HW channel can be selected at a time.
		*
		* Returns
		* D0 - Either:
		*      *) -1, .ifeq	the FX can't be played (f.ex. due to priority)
		*      *) Hardware/software channel combination the FX will be played
		*         on. (f.ex. DMAF_AUD0|MIX_CH2)
MixerPlayFX:
		.ifeq	MIXER_TIMING_BARS-1
			move.w	#MIXER_OTHER_COLOUR,0xdff180
		.endif
		move.w	d2,-(sp)
		movem.l	d1/d4-d7/a1/a2/a6,-(sp)		| Stack

		* Fetch the correct mixer entry
		bsr		MixerFetchEntry
		
		.ifeq	MIXER_SINGLE-1
			* Set HW channel to correct channel for single mixing
			move.w	#mxsingledma,d0
		.endif
		
		* Pre-fetch elements from structure as needed
		move.w	mfx_priority(a0),d2
		.ifeq	mxslength_word-1
			move.w	mfx_length+2(a0),d1
		.else
			move.l	mfx_length(a0),d1
		.endif
		
		* Set up to search for best channel
		move.w	#-32768,d4					| Best priority found
		moveq	#0,d5						| Reset best age found
		moveq	#0,d6						| Best channel found
		move.l	d6,a2						| Reset best channel pointer
		
		* For each mixer channel, check availability
		.ifeq	MIXER_68020-1
			* Set up for loop
			swap	d0						| Swap HW channel
			
			move.w	#4,d7					| Channel bit
			swap	d7
			move.w	#mixer_sw_channels-1,d7	| Loop counter
			
0:
		swap	d7						| Channel bit
			MixChkChan 0
			addq.w	#1,d7					| Next channel
			swap	d7						| Loop counter
			dbra	d7,0b
			
			swap	d0						| Swap back HW channel
		.else
			MixChkChan 0					| Check MIX_CH0
			.if	mixer_sw_channels>=2
				MixChkChan 1				| Check MIX_CH1
			.endif
			.if	mixer_sw_channels>=3
				MixChkChan 2				| Check MIX_CH2
			.endif
			.if	mixer_sw_channels==4
				MixChkChan 3				| Check MIX_CH3
			.endif
		.endif
		
		* Check if any channel was found based on priority
		tst.w	d6
		bne.s	prio_found
		
		* No channels are free
		moveq	#-1,d0
		bra		done
		
prio_found:
		* Found a lower priority/older channel
		move.l	a2,a1

.found:
		* Found a free channel, add the sample
		.ifeq	mxsize_x32-1
			and.w	#0xffe0,d1				| Limit to multiple of 32 bytes
		.else
			and.w	#0xfffc,d1				| Limit to multiple of  4 bytes
		.endif
		
		*.ifeq	MIXER_ENABLE_PLUGINS-1
			or.w	d6,d0					| Set HW/Mixer channel in D0
		*.endif
		
		bsr		MixerChannelWrite
		tst.w	d0							| Set condition codes

done:
		movem.l	(sp)+,d1/d4-d7/a1/a2/a6		| Stack
		move.w	(sp)+,d2

		.ifeq	MIXER_TIMING_BARS-1
			move.w	#MIXER_DEFAULT_COLOUR,0xdff180
			tst.w	d0						| Restore condition code
		.endif
		rts
		
		* Routine: MixerPlayChannelFX
		* This routine plays the given FX on the given hardware/mixer channel
		* combination. Priority and channel availability are taken into 
		* account.
		*
		* Fails quietly if the selected hardware/mixer channel combination is not free.
		*
		* Note: this routine does not check .ifeq	the HW channel selected is 
		*       available to the mixer, .ifeq	an unused HW channel is 
		*       selected, no sample will be played back. This only applies .ifeq	*       MIXER_MULTI=1 or  MIXER_MULTI_PAIRED=1.
		* Note: this routine does not check .ifeq	the mixer is running with 
		*       enough mixed channels for the required mixer channel to be
		*       in use. .ifeq	the mixer channel is not in use, no FX will be
		*       played back.
		* Note: once playing, looping FX can only be ended by calling
		*       MixerStopFX. Until this happens, a looping FX will occupy a
		*       mixer channel forever, regardless of the priority of any
		*       incoming FX playback requests.
		*
		*       Keep in mind that the initial playback request for a looping
		*       FX will follow priorities as normal to determine .ifeq	it can 
		*       start playing.
		*
		* A0 - Pointer to MXEffect structure for the FX to play
		* D0 - Hardware channel/mixer channel (f.ex. DMAF_AUD0|MIX_CH1)
		*      Supports setting exactly one mixer channel.
		*
		*      Note: .ifeq	MIXER_SINGLE-1, hardware channel selection is ignored.
		*      Note: .ifeq	MIXER_MULTI_PAIRED-1, DMAF_AUD3 is not a valid
		*            channel.
		*      Note: Only one HW channel can be selected at a time.
		*
		* Returns
		* D0 - Either:
		*      *) -1, .ifeq	the FX can't be played (f.ex. due to priority)
		*      *) Hardware/software channel combination the FX will be played
		*         on. (f.ex. DMAF_AUD0|MIX_CH1)
MixerPlayChannelFX:
		.ifeq	MIXER_TIMING_BARS-1
			move.w	#MIXER_OTHER_COLOUR,0xdff180
		.endif
		move.w	d2,-(sp)
		movem.l	d1/d6/d7/a1/a6,-(sp)			| Stack
		
		* Fetch the correct mixer entry
		bsr		MixerFetchEntry
		
		.ifeq	MIXER_SINGLE-1
			* Set HW channel to correct channel for single mixing
			move.w	#mxsingledma,d2
			and.w	#0xf0,d0
			or.w	d2,d0
		.endif
		
		.ifeq	MIXER_ENABLE_PLUGINS-1
			move.w	d0,d6						| Save HW/Mixer channel
		.endif
		
		* Pre-fetch elements from structure as needed
		move.w	mfx_priority(a0),d2
		.ifeq	mxslength_word-1
			move.w	mfx_length+2(a0),d1
		.else
			move.l	mfx_length(a0),d1
		.endif

		* Jump to selected channel
		move.w	d0,d7
		asr.w	#4,d7
		add.w	d7,d7
		add.w	d7,d7
		jmp		chjmp_table(pc,d7.w)

		* Jump table
		* The empty space included in the table is required for the 
		* conversion between channel bit and channel number.
chjmp_table:
		nop
		nop
		jmp	ch0(pc)
		jmp	ch1(pc)
		.long	0
		jmp	ch2(pc)
		.long	0,0,0
			
ch3:	lea.l	mch_SIZEOF(a1),a1
ch2:	lea.l	mch_SIZEOF(a1),a1
ch1:	lea.l	mch_SIZEOF(a1),a1
ch0:		
		* Check .ifeq	the channel can be used
		swap	d0
		move.w	mch_status(a1),d7
		smi		d0
		or.b	d0,d7
		swap	d0
		addq.w	#1,d7
		add.w	d7,d7
		add.w	d7,d7
		jmp		stjmp_table(pc,d7.w)
		
		* Jump table for the different statuses (free, in use, looping)
stjmp_table:
		jmp		.not_free(pc)
		jmp		.play_fx(pc)
		jmp		.check_priority(pc)
		
.check_priority:
		* Check if the priority of the new FX is equal or higher than the
		* currently playing FX.
		cmp.w	mch_priority(a1),d2
		bge.s	.play_fx
		
		* Channel is not free
.not_free:
		moveq	#-1,d0
		bra		0f
		
.play_fx:
		* Add sample to selected channel here
		.ifeq	mxsize_x32-1
			and.w	#0xffe0,d1				| Limit to multiple of 32 bytes
		.else
			and.w	#0xfffc,d1				| Limit to multiple of  4 bytes
		.endif
		
		.ifeq	MIXER_ENABLE_PLUGINS-1
			move.w	d6,d0					| Restore HW/Mixer channel
		.endif
		
		bsr		MixerChannelWrite
		tst.w	d0							| Set return value

0:		
		movem.l	(sp)+,d1/d6/d7/a1/a6		| Stack
		move.w	(sp)+,d2
		
		.ifeq	MIXER_TIMING_BARS-1
			move.w	#MIXER_DEFAULT_COLOUR,0xdff180
			tst.w	d0						| Restore condition code
		.endif
		rts

		* Routine: MixerStopFX
		* This routine stops playback on the given hardware/mixer channel(s).
		*
		* Note: this routine supports selecting multiple hardware and mixer
		*       channels in a single call. In this case, the relevant mixer
		*       channels stop playback on all selected hardware channels.
		*
		* D0 - Hardware channel/mixer channel mask (f.ex. DMAF_AUD0|MIX_CH1)
		*      Note: .ifeq	MIXER_SINGLE-1, hardware channel selection is ignored.
MixerStopFX:
		.ifeq	MIXER_TIMING_BARS-1
			move.w	#MIXER_OTHER_COLOUR,0xdff180
		.endif
		.ifeq	MIXER_SINGLE-1
			.ifeq	MIXER_68020-1
				movem.l	d0-d2/d7/a0,-(sp)	| Stack
			.else
				movem.l	d0/d1/a0,-(sp)		| Stack
			.endif
			and.w	#0xfff0,d0
			or.w	#mxsingledma,d0			| Set correct hardware channel
		.else
			.ifeq	MIXER_68020-1
				movem.l	d0-d3/d6/d7/a0/a1,-(sp)	| Stack
			.else
				movem.l	d0-d2/d7/a0/a1,-(sp)	| Stack
			.endif
		.endif
		
		* Fetch mixer & setup for stopping FX
		lea.l	mixer(pc),a0
		moveq	#MIXER_CHAN_INACTIVE,d1

		* Single mixer path
		.ifeq	MIXER_SINGLE-1
			* Fetch the first mixer entry/channel
			lea.l	mx_mixer_entries+mxe_channels(a0),a0
			
			* Check each channel
			.ifeq	MIXER_68020-1
				* Set up for loop
				moveq	#4,d2
				moveq	#4-1,d7
				
.chlp:			btst	d2,d0
				beq.s	.nxt_ch

				move.w	d1,mch_status(a0)
		
.nxt_ch:			lea.l	mch_SIZEOF(a0),a0
				addq.w	#1,d2
				dbra	d7,.chlp
			.else
				btst	#4,d0				| Check channel 0
				beq.s	.ch1

				move.w	d1,mch_status(a0)
			
.ch1:			btst	#5,d0				| Check channel 1
				beq.s	.ch2
			
				move.w	d1,mch_status+mch_SIZEOF(a0)
			
.ch2:			btst	#6,d0				| Check channel 2
				beq.s	.ch3
			
				move.w	d1,mch_status+(mch_SIZEOF*2)(a0)
			
.ch3:			btst	#7,d0				| Check channel 3
				beq.s	.stopfx_done
			
				move.w	d1,mch_status+(mch_SIZEOF*3)(a0)
.stopfx_done:
			.endif
		.endif

		* Multi mixer path
		.ifeq	MIXER_SINGLE
			* Fetch first mixer entry
			lea.l	mx_mixer_entries(a0),a0
			
			* Set up for loop
			moveq	#4-1,d7
			moveq	#0,d2
			
			* Loop over mixer entries
.lp			lea.l	mxe_channels(a0),a1
			btst	d2,d0
			beq.s	.next_entry
			
			* Check each channel for current entry
			.ifeq	MIXER_68020-1
				* Set up for loop
				moveq	#4,d3
				moveq	#4-1,d6
				
.chlp			btst	d3,d0
				beq.s	.nxt_ch

				move.w	d1,mch_status(a1)
		
.nxt_ch			lea.l	mch_SIZEOF(a1),a1
				addq.w	#1,d3
				dbra	d6,.chlp
			.else
				btst	#4,d0				| Check channel 0
				beq.s	.ch1
			
				move.w	d1,mch_status(a1)
			
.ch1			btst	#5,d0				| Check channel 1
				beq.s	.ch2
			
				move.w	d1,mch_status+mch_SIZEOF(a1)
			
.ch2			btst	#6,d0				| Check channel 2
				beq.s	.ch3
			
				move.w	d1,mch_status+(mch_SIZEOF*2)(a1)
			
.ch3			btst	#7,d0				| Check channel 3
				beq.s	.next_entry
			
				move.w	d1,mch_status+(mch_SIZEOF*3)(a1)
			.endif
			
			* Loop back
.next_entry	lea.l	mxe_SIZEOF(a0),a0
			addq.w	#1,d2
			dbra	d7,.lp
		.endif
		
		.ifeq	MIXER_SINGLE-1
			.ifeq	MIXER_68020-1
				movem.l	(sp)+,d0-d2/d7/a0	| Stack
			.else
				movem.l	(sp)+,d0/d1/a0		| Stack
			.endif
		.else
			.ifeq	MIXER_68020-1
				movem.l	(sp)+,d0-d3/d6/d7/a0/a1	| Stack
			.else
				movem.l	(sp)+,d0-d2/d7/a0/a1	| Stack
			.endif
		.endif
		.ifeq	MIXER_TIMING_BARS-1
			move.w	#MIXER_DEFAULT_COLOUR,0xdff180
		.endif
		rts

*-----------------------------------------------------------------------------
* Interrupt 	.macro	handlers
*-----------------------------------------------------------------------------
		* Macro: MixSingIHstart
		* 	.macro	This forms the start of the mixer audio interrupt handler in
		* case MIXER_SINGLE=1. Implemented as 	.macro	a for performance reasons
		* and to prevent double code.
	.macro	MixSingIHstart
		.ifeq	MIXER_TIMING_BARS-1
			move.w	#MIXER_IH_COLOUR,0xdff180
		.endif
		.ifeq	MIXER_CIA_TIMER-1
			CIAStart
		.endif
		movem.l	d0-d7/a0-a6,-(sp)				| Stack
		
		* Fetch custombase & mixer / mixer entry
		lea.l	mxcustombase,a6
		lea.l	mixer+mx_mixer_entries(pc),a1
		
		* Acknowledge interrupt
		move.w	mixer+mx_irq_bits(pc),intreq(a6)
		
		* Fetch and swap buffers
		lea.l	mxe_buffers(a1),a2
		move.l	(a2)+,d0							| Fetch
		move.l	(a2)+,a0
		move.l	d0,-(a2)							| Swap
		move.l	a0,-(a2)							| Use current buffer
		
		* Get audio channel
		lea.l	mxsinglechan(a6),a6

		* Play current buffer
		move.l	a0,ac_ptr(a6)
		move.l	mixer+mx_hw_period(pc),ac_per(a6)	| Period & volume
		
		* Run mixer
		.ifeq	MIXER_TIMING_BARS-1
			move.w	#MIXER_CHUPD_COLOUR,0xdff180
		.endif
				.endm
				
		* Macro: MixSingIHend
		* 	.macro	This forms the end of the mixer audio interrupt handler in
		* case MIXER_SINGLE=1. Implemented as 	.macro	a for performance reasons
		* and to prevent double code.				
	.macro	MixSingIHend
		.ifeq	MIXER_TIMING_BARS-1
			move.w	#MIXER_IH_COLOUR,0xdff180
		.endif
		movem.l	(sp)+,d0-d7/a0-a6		| Stack
		.ifeq	MIXER_CIA_TIMER-1
			CIAStop
		.endif
		.ifeq	MIXER_COUNTER-1
			move.l	a0,-(sp)			| Stack
			
			lea.l	mixer(pc),a0
			addq.w	#1,mx_counter(a0)
			
			move.l	(sp)+,a0			| Stack
		.endif
		.ifeq	MIXER_TIMING_BARS-1
			move.w	#MIXER_DEFAULT_COLOUR,0xdff180
		.endif
		rte
				.endm

		* Macro: MixMultIHstart
		* 	.macro	This forms the start of the mixer audio interrupt handler in
		* case MIXER_MULTI=1 or MIXER_MULTI_PAIRED=1. Implemented as 	.macro	a
		* for performance reasons and to prevent double code.
	.macro	MixMultIHstart
		.ifeq	MIXER_TIMING_BARS-1
			move.w	#MIXER_IH_COLOUR,0xdff180
		.endif
		.ifeq	MIXER_CIA_TIMER-1
			CIAStart
		.endif
		movem.l	d0-d7/a0-a6,-(sp)			| Stack
		
		* Fetch custombase & mixer / mixer entry / IRQ bits
		lea.l	mxcustombase,a6
		lea.l	mixer+mx_mixer_entries(pc),a1
		
		* Fetch current interrupts and mask out irrelevant ones
		move.w	intreqr(a6),d4
		and.w	mixer+mx_irq_bits(pc),d4
		
		* Set up for looping over each mixer entry
		moveq	#4-1,d7					| Check all channels
		move.w	#aud,d6
		moveq	#7,d5					| First audio interrupt bit

		* Loop over each mixer entry
.entry_lp
		.ifeq	MIXER_MULTI_PAIRED-1
			cmp.w	#10,d5
			bne.s	.test_channel_bit
			
			* Paired channel: get last buffer
			lea.l	mxe_buffers(a1),a2
			move.l	(a2),a0					| Get current buffer
			tst.w	mxe_active(a1)
			bne.s	.acknowledge_irq
	
			move.l	mixer+mx_empty_buffer(pc),a0
			bra.s	.acknowledge_irq
		.endif
.test_channel_bit
		btst	d5,d4						| Test .ifeq	channel is active
		beq		.next_entry

		* Fetch and swap buffers
		lea.l	mxe_buffers(a1),a2
		move.l	(a2)+,d0					| Fetch
		move.l	(a2)+,a0
		move.l	d0,-(a2)					| Swap
		move.l	a0,-(a2)					| Use current buffer

.acknowledge_irq
		* Acknowledge interrupts
		moveq	#0,d4
		bset	d5,d4					| D4 = correct IRQ bit
		move.w	d4,intreq(a6)			| Acknowledge IRQ
			
		* Play current buffer
		move.l	a0,ac_ptr(a6,d6.w)
		move.l	mixer+mx_hw_period(pc),ac_per(a6,d6.w)	| Period & volume
		
		.ifeq	MIXER_MULTI_PAIRED-1
			* Skip mixing for the paired channel
			cmp.w	#10,d5
			beq		.end_handler
		.endif
		
		.ifeq	MIXER_68020
			movem.l	d5-d7,-(sp)				| Stack
		.else
			move.l	d7,-(sp)				| Stack
		.endif
		
		.ifeq	MIXER_TIMING_BARS-1
			move.w	#MIXER_CHUPD_COLOUR,0xdff180
		.endif
		* Run the mixer
				.endm

		* Macro: MixMultIHend
		* 	.macro	This forms the end of the mixer audio interrupt handler in
		* case MIXER_MULTI=1 or MIXER_MULTI_PAIRED=1. Implemented as 	.macro	a
		* for performance reasons and to prevent double code.
	.macro	MixMultIHend
		.ifeq	MIXER_TIMING_BARS-1
			move.w	#MIXER_IH_COLOUR,0xdff180
		.endif
		.ifeq	MIXER_68020
			movem.l	(sp)+,d5-d7				| Stack
		.else
			move.l	(sp)+,d7				| Stack
		.endif
		bra.s	.end_handler
		
.next_entry
		.ifeq	MIXER_TIMING_BARS-1
			move.w	#MIXER_IH_COLOUR,0xdff180
		.endif
		
		* Fetch next entry & set up next audio channel
		.ifeq	MIXER_MULTI_PAIRED-1
			cmp.w	#9,d5
			beq.s	.paired_skip
		.endif
		lea.l	mxe_SIZEOF(a1),a1
		
.paired_skip
		addq.w	#1,d5						| Next channel bit to test
		add.w	#ac_SIZEOF,d6				| Next audio channel
		dbra	d7,.entry_lp

		* End of handler
.end_handler
		movem.l	(sp)+,d0-d7/a0-a6			| Stack
		.ifeq	MIXER_CIA_TIMER-1
			CIAStop
		.endif
		.ifeq	MIXER_COUNTER-1
			move.l	a0,-(sp)			| Stack
			
			lea.l	mixer(pc),a0
			addq.w	#1,mx_counter(a0)
			
			move.l	(sp)+,a0			| Stack
		.endif
		.ifeq	MIXER_TIMING_BARS-1
			move.w	#MIXER_DEFAULT_COLOUR,0xdff180
		.endif
		rte
				.endm

*-----------------------------------------------------------------------------
* 	.macro	Mixers
*-----------------------------------------------------------------------------
		* Macro: MixSingleLongWord
		* 	.macro	This mixes a single longword to the given data register, 
		* across the given number of channels.
		*
		* \1 - destination register number
		* \2 - number of channels to mix
	.macro	MixSingleLongWord	arg1,arg2
		add.l	(a3)+,\arg1
		.if	\arg2>2
			add.l	(a4)+,\arg1
		.endif
		.if	\arg2>3
			add.l	(a5)+,\arg1
		.endif
					.endm

		* Macro: MixLongWords
		* 	.macro	This mixes 8 longwords (32 bytes) to all 8 data registers,
		* across the given number of channels.
		*
		* \1 number of channels to mix
	.macro	MixLongWords	nb_channels
		MixSingleLongWord d0,\nb_channels
		MixSingleLongWord d1,\nb_channels
		MixSingleLongWord d2,\nb_channels
		MixSingleLongWord d3,\nb_channels
		MixSingleLongWord d4,\nb_channels
		MixSingleLongWord d5,\nb_channels
		MixSingleLongWord d6,\nb_channels
		MixSingleLongWord d7,\nb_channels
					.endm
					
		* Macro: MixJump32
		* 	.macro	This determines how many blocks of 32 bytes need to be mixed
		* (up to mx_buffer_size)
		*
		* \1 - number of channels
	.macro	MixJump32	arg
		* Push remaining length/bytes to process on stack
		move.w	d1,-(sp)
		move.w	d7,-(sp)
		move.w	d1,d6
		.ifeq	mxsize_x32
			and.w	#0xffe0,d6				| D6 = bytes to process
		.endif
		move.w	d6,a6						| Store bytes processed in A6
		
		* Calculate position in the jumptable
		asr.w	#3,d6
		jmp		.mix_\arg\()ch_jmp_table32(pc,d6.w)
			.endm

		* Macro: MixBlock32
		* 	.macro	This mixes in blocks of 32 bytes (up to mx_buffer_size)
		*
		* \1 - number of channels
	.macro	MixBlock32	arg
		* The jump table below is dynamically generated based on the sample
		* buffer size & the size of a 32 byte mixing block.
.mix_\arg\()ch_jmp_table32:
		* Calculate maximum offset
.mix_\arg\()ch_jmpoff32	= .mix_\arg\()ch_32b+((mixer_32b_cnt-1)*.mix_\arg\()ch_32b_sz)
		* Generate jump table
		.ifeq	mxsize_x32-1
			jmp	.mix_\arg\()ch_calcrem4_st(pc)
		.else
			jmp	.mix_\arg\()ch_4b_setup_st(pc)
		.endif
		.set REPTN,0
		.rept mixer_32b_cnt-1
		jmp	.mix_\arg\()ch_jmpoff32-(REPTN*.mix_\arg\()ch_32b_sz)(pc)
		.set	REPTN,REPTN+1
		.endr
		
		* 1st block: 32 byte increments
.mix_\arg\()ch_32b:
		movem.l	(a2)+,d0-d7
		.if	\arg>1
			MixLongWords \arg
		.endif
		movem.l	d0-d7,(a0)
		lea.l	32(a0),a0
.mix_\arg\()ch_32b_single:
.mix_\arg\()ch_32b_sz = .mix_\arg\()ch_32b_single-.mix_\arg\()ch_32b
		
		.rept mixer_32b_cnt-1
		movem.l	(a2)+,d0-d7
		.if	\arg>1
			MixLongWords \arg
		.endif
		movem.l	d0-d7,(a0)
		lea.l	32(a0),a0		
		.endr
			.endm

		* Macro: MixChkRem32
		* 	.macro	This checks .ifeq	any work still needs to be done after mixing in
		* blocks of 32 bytes.
		*
		* \1 - number of channels
	.macro	MixChkRem32	arg
.mix_\arg\()ch_chkrem32:
		* Pull remaining length/remaining bytes to mix of the stack
		move.w	(sp)+,d7
		move.w	(sp)+,d1
		
		* Check processed byte count vs smallest remaining byte count
		cmp.w	a6,d1
		bne.s	.mix_\arg\()ch_4b_setup
		bra		.mix_\arg\()ch_calcrem4
				.endm

		* Macro: MixJump4
		* 	.macro	This decides how many blocks of 4 bytes need to be mixed (up
		* to 32 bytes)
		*
		* \1 - number of channels
	.macro	MixJump4	arg
.mix_\arg\()ch_4b_setup_st:
		* Update stack position
		lea.l	4(sp),sp

.mix_\arg\()ch_4b_setup:
		* Set up for the 4 byte blocks
		move.w	d1,d6
		sub.w	a6,d6						| Determine remaining amount of
											* bytes to proces.

		* Jump to the correct position in the jumptable
		jmp		.mix_\arg\()ch_jmp_table4(pc,d6.w)
			.endm

		* Macro: MixBlock4
		* 	.macro	This mixes up to 32 bytes of sample data.
		*
		* \1 - number of channels
	.macro	MixBlock4	arg
.mix_\arg\()ch_jmp_table4:
		* Calculate maximum offset
.mix_\arg\()ch_jmpoff4	= .mix_\arg\()ch_4b+(6*.mix_\arg\()ch_4b_sz)
		* Generate jump table
		jmp	.mix_\arg\()ch_calcrem4(pc)
		.rept 6
		.set	REPTN,0
		jmp	.mix_\arg\()ch_jmpoff4-(REPTN*.mix_\arg\()ch_4b_sz)(pc)
		.set	REPTN,REPTN+1
		.endr

		* 2nd block: 4 byte increments
.mix_\arg\()ch_4b:
		.ifeq	\arg-1
			move.l	(a2)+,(a0)+
		.endif
		.if	\arg>1
			move.l	(a2)+,d0
			MixSingleLongWord d0,\arg
			move.l	d0,(a0)+
		.endif
.mix_\arg\()ch_4b_single:
.mix_\arg\()ch_4b_sz	= .mix_\arg\()ch_4b_single-.mix_\arg\()ch_4b

		.rept 6
		.set	REPTN,0
		.ifeq	\arg-1
			move.l	(a2)+,(a0)+
		.endif
		.if	\arg>1
			move.l	(a2)+,d0
			MixSingleLongWord d0,\arg
			move.l	d0,(a0)+
		.endif
		.set	REPTN,REPTN+1
		.endr
			.endm

		* Macro: MixCalcRem4
		* 	.macro	This calculates how many longwords still need to be mixed and
		* checks & updates channels .ifeq	needed.
		*
		* \1 - number of channels
	.macro	MixCalcRem4	arg
.mix_\arg\()ch_calcrem4_st:
		.ifeq	mxsize_x32-1
			move.w	(sp)+,d7
			move.w	(sp)+,d1
		.endif
.mix_\arg\()ch_calcrem4:
		* Update remaining bytes & smallest remaining length
		.ifeq	mxslength_word-1
			move.w	d1,d2
			sub.w	d1,d7
			move.w	d7,d1
		.else
			ext.l	d1
			move.l	d1,d2
			sub.w	d1,d7
			move.w	d7,d1
		.endif

		* Reset channel counter
		moveq	#0,d0

		* Check all active channels
		MixCheckChannel a2
		.if	\arg>1
			MixCheckChannel a3
		.endif
		.if	\arg>2
			MixCheckChannel a4
		.endif
		.if	\arg>3
			MixCheckChannel a5
		.endif
		
		* Check .ifeq	any bytes still need to be mixed
		tst.w	d1
		bne		.mix_\arg\()ch_start
		bra		.mix_done
			.endm
			
		* Macro: MixLoop020
		* 	.macro	This mixes the given number of channels together in a simple
		* loop. This is faster on 68020+ by making use of the instruction
		* cache.
		*
		* \1 - number of channels
	.macro	MixLoop020	arg
		* Set up for loop
		move.w	d1,d3
		asr.w	#2,d3						| Convert to number of longwords
		subq.w	#1,d3
		
.mix_\arg\()ch_lp:
		.ifeq	\arg-1
			move.l	(a2)+,(a0)+
		.endif
		.if	\arg>1
			move.l	(a2)+,d0
			MixSingleLongWord d0,\arg
			move.l	d0,(a0)+
		.endif
		dbra	d3,.mix_\arg\()ch_lp
			.endm

		* Macro: MixHQInnerLP
		* 	.macro	This forms the core of the inner loop of the HQ mix loop
		*
		* \1 - number of channels
		* \2 - overflow postfix (68000 only)
	.macro	MixHQInnerLP	arg
		.ifeq	MIXER_68020-1
			moveq	#4-1,d7
.mix_\arg\()ch_ilp:
			add.b	d2,d0
			bvs.s	.mix_\arg\()ch_overflow
			.if	\arg>2
				add.b	d5,d0
				bvs.s	.mix_\arg\()ch_overflow
			.endif
			.if	\arg>3
				add.b	d6,d0
				bvs.s	.mix_\arg\()ch_overflow
			.endif
				
.mix_\arg\()ch_ilp_done:
			ror.l	#8,d0
			lsr.l	#8,d2
			.if	\arg>2
				lsr.l	#8,d5
			.endif
			.if	\arg>3
				lsr.l	#8,d6
			.endif
			dbra	d7,.mix_\arg\()ch_ilp
		.else
			move.b	(a2)+,d0
			add.b	(a3)+,d0
			bvs.s	.mix_\arg\()ch_overflow_1_\<REPTN>
			.if	\arg>2
				add.b	(a4)+,d0
				bvs.s	.mix_\arg\()ch_overflow_2_\<REPTN>
			.endif
			.if	\arg>3
				add.b	(a5)+,d0
				bvs.s	.mix_\arg\()ch_overflow_3_\<REPTN>
			.endif
.mix_\arg\()ch_ilp_done_\<REPTN>
			move.b	d0,(a0)+
		.endif
				.endm
				
		* Macro: MixHQOverflow
		* 	.macro	This forms the overflow checking part of the HQ mixer
		*
		* \1 - number of channels
	.macro	MixHQOverflow	arg
		.ifeq	MIXER_68020-1
.mix_\arg\()ch_overflow
			smi		d0						| 0xff .ifeq	negative, 0x0 .ifeq	positive
			add.b	d4,d0					| 0x0+0x80 = 0x80, 0xff+0x80 = 0x7f
			bra.s	.mix_\arg\()ch_ilp_done
		.else
.mix_\arg\()ch_overflow_1_\<REPTN>
			smi		d0						| 0xff .ifeq	negative, 0x0 .ifeq	positive
			add.b	d4,d0					| 0x0+0x80 = 0x80, 0xff+0x80 = 0x7f
			.if	\arg>2
				move.b	(a4)+,d2
			.endif
			.if	\arg>3
				move.b	(a5)+,d2
			.endif
			bra.s	.mix_\arg\()ch_ilp_done_\<REPTN>
.mix_\arg\()ch_overflow_2_\<REPTN>
			smi		d0						| 0xff .ifeq	negative, 0x0 .ifeq	positive
			add.b	d4,d0					| 0x0+0x80 = 0x80, 0xff+0x80 = 0x7f
			.if	\arg>3
				move.b	(a5)+,d2
			.endif
			bra.s	.mix_\arg\()ch_ilp_done_\<REPTN>
.mix_\arg\()ch_overflow_3_\<REPTN>
			smi		d0						| 0xff .ifeq	negative, 0x0 .ifeq	positive
			add.b	d4,d0					| 0x0+0x80 = 0x80, 0xff+0x80 = 0x7f
				bra.s	.mix_\arg\()ch_ilp_done_\<REPTN>
		.endif
				.endm
		
			
		* Macro: MixLoopHQ
		* 	.macro	This mixes the given number of channels together in a simple
		* loop. This is the HQ mode version, which can handle overflow.
		*
		* \1 - number of channels
	.macro	MixLoopHQ	arg
		movem.l	d2/d4-d7,-(sp)				| Stack

		* Set up for loop
		moveq	#-0x80,d4					| For setting correct sign
		move.w	d1,d3
		asr.w	#2,d3						| Convert to number of longwords
		subq.w	#1,d3
		
.mix_\arg\()ch_lp
		.ifeq	\arg-1
			move.l	(a2)+,(a0)+
		.endif
		.if	\arg>1
			.ifeq	MIXER_68020-1
				move.l	(a2)+,d0
				move.l	(a3)+,d2
				.if	\arg>2
					move.l	(a4)+,d5
				.endif
				.if	\arg>3
					move.l	(a5)+,d6
				.endif
				
				MixHQInnerLP \arg
				
				move.l	d0,(a0)+
			.else
				REPT 4
					MixHQInnerLP \arg
				ENDR
			.endif
		.endif
		dbra	d3,.mix_\arg\()ch_lp
		.if	\arg>1
			bra.s	.mix_\arg\()ch_lp_done
		.endif
		
		.if	\arg>1
			.ifeq	MIXER_68020-1
				MixHQOverflow \1
			.else
				REPT 4
					MixHQOverflow \1
				ENDR
			.endif
		.endif

.mix_\arg\()ch_lp_done:
		movem.l	(sp)+,d2/d4-d7			| Stack
			.endm
			
		* Macro: MixBlockBufSize
		* 	.macro	This mixes the given number of channels together in a
		* single unrolled block that always mixes the full sample buffer
		* size in one go.
		*
		* \1 - number of channels
	.macro	MixBlockBufSize	arg
		* Calculate block repetition counts
.mix_\arg\()ch_pal_size_32		= mixer_PAL_buffer_size&0xffe0
.mix_\arg\()ch_ntsc_size_32		= mixer_NTSC_buffer_size&0xffe0
.mix_\arg\()ch_pal_diff_4		= mixer_PAL_buffer_size-.mix_\arg\()ch_pal_size_32
.mix_\arg\()ch_ntsc_diff_4		= mixer_NTSC_buffer_size-.mix_\arg\()ch_ntsc_size_32

		* Check PAL/NTSC flag
		move.w	mixer+mx_vidsys(pc),d0
		bne		.mix_\arg\()ch_blk_ntsc

		* PAL block (32 bytes)
		REPT (.mix_\arg\()ch_pal_size_32)/32
			movem.l	(a2)+,d0-d7
			.if	\arg>1
				MixLongWords \arg
			.endif
			movem.l	d0-d7,(a0)
			lea.l	32(a0),a0	
		ENDR
		.ifeq	mxsize_x32
			* PAL block (4 bytes)
			REPT (.mix_\arg\()ch_pal_diff_4)/4
				.ifeq	\arg-1
					move.l	(a2)+,(a0)+
				.endif
				.if	\arg>1
					move.l	(a2)+,d0
					MixSingleLongWord d0,\arg
					move.l	d0,(a0)+
				.endif
			ENDR
		.endif
		bra		.mix_done

.mix_\arg\()ch_blk_ntsc:
		* NTSC block
		REPT (.mix_\arg\()ch_ntsc_size_32)/32
			movem.l	(a2)+,d0-d7
			.if	\arg>1
				MixLongWords \arg
			.endif
			movem.l	d0-d7,(a0)
			lea.l	32(a0),a0
		ENDR
		.ifeq	mxsize_x32
			REPT (.mix_\arg\()ch_ntsc_diff_4)/4
				.ifeq	\arg-1
					move.l	(a2)+,(a0)+
				.endif
				.if	\arg>1
					move.l	(a2)+,d0
					MixSingleLongWord d0,\arg
					move.l	d0,(a0)+
				.endif
			ENDR
		.endif
		bra		.mix_done
				.endm

		* Macro: MixCheckChannel
		* 	.macro	This checks the given channel and resets it .ifeq	needed based 
		* on remaining size.
		*
		* \1 - pointer to use
	.macro	MixCheckChannel	arg
.\@_chkch_wlen_dist	=	MIXER_ENABLE_PLUGINS+MIXER_ENABLE_CALLBACK
		* Update sample remaining length and check for underflows
		move.l	mxe_active_channels(a1,d0.w),a6
		.ifeq	mxslength_word-1
			move.w	mch_remaining_length(a6),d3	| D3 = remaining length
			sub.w	d2,d3						| Update remaining length
			.if	.\@_chkch_wlen_dist>=1
				bhi		.\@_write_remaining
			.else
				bhi.s	.\@_write_remaining
			.endif
		.else
			move.l	mch_remaining_length(a6),d3	| D3 = remaining length
			sub.l	d2,d3						| Update remaining length
			.if	.\@_chkch_wlen_dist>=1
				bgt		.\@_write_remaining
			.else
				bgt.s	.\@_write_remaining
			.endif
		.endif

		* Zero bytes remain
		clr.b	mch_status+1(a6)			| Clear active status for 
											* non-looping samples
		.ifeq	mxslength_word-1
			move.w	mch_loop_length(a6),d3	| Fetch total length
		.else
			move.l	mch_loop_length(a6),d3	| Fetch total length
		.endif
		.ifeq	MIXER_ENABLE_PLUGINS-1
			.ifeq	MIXER_TIMING_BARS-1
				move.w	#MIXER_PLUGIN_COLOUR,0xdff180
			.endif
			* Check .ifeq	a plugin is set
			move.l	d7,d6
			move.l	mch_plugin_ptr(a6),d7
			beq.s	.\@_no_plugin
			
			* Check plugin type (NODATA plugins always fire, .align	2 at 0 bytes
			* remaining)
			tst.w	mch_plugin_type(a6)
			bne.s	.\@_no_data_plugin
			
			* Check .ifeq	this is a one-shot sample (= no standard plugin) or .ifeq	* the remaining number of bytes to process is zero.
			tst.w	d1
			beq.s	.\@_no_plugin
			
			tst.w	mch_status(a6)
			bmi.s	.\@_run_plugin
			
.\@_no_plugin:
			move.l	mch_loop_ptr(a6),\arg		| No plugin in use
			bra.s	.\@_plugin_done
			
.\@_no_data_plugin:
			move.l	d0,d4
			move.l	d1,d5
			movem.l	a0-a1/a6,-(sp)
			move.l	mch_loop_ptr(a6),a0
			bra.s	.\@_plugin_address_set
			
.\@_run_plugin:
			* Run the plugin
			move.l	d0,d4
			move.l	d1,d5
			movem.l	a0-a1/a6,-(sp)
			move.l	mch_plugin_output_buffer(a6),a0

.\@_plugin_address_set:
			move.l	a0,\arg					| Update pointer

			* Set up parameters
			.ifeq	mxslength_word-1
				move.w	d1,d0
				cmp.w	mch_loop_length(a6),d0
				bls.s	.\@_plugin_len_set
				
				move.w	mch_loop_length(a6),d0
			.else
				moveq	#0,d0
				move.w	d1,d0
				cmp.l	mch_loop_length(a6),d0
				bls.s	.\@_plugin_len_set
				
				move.l	mch_loop_length(a6),d0
			.endif
			
.\@_plugin_len_set:
			move.l	mch_plugin_data_ptr(a6),a1	| Fetch data
			
			* Set loop status
			moveq	#0,d1
			tst.w	mch_status(a6)
			sne		d1

			move.l	a2,-(sp)
			move.l	a6,a2						| Channel info in A2
			move.l	d7,a6
			jsr		(a6)						| Call plugin
			
			move.l	(sp)+,a2
			movem.l	(sp)+,a0-a1/a6
			move.l	d4,d0
			move.l	d5,d1

.\@_plugin_done:
			move.l	d6,d7
			.ifeq	MIXER_TIMING_BARS-1
				move.w	#MIXER_AUD_COLOUR,0xdff180
			.endif
		.else
			move.l	mch_loop_ptr(a6),\arg		| Update pointer
		.endif
		
		.ifeq	MIXER_ENABLE_CALLBACK-1
			* Check .ifeq	this is a looping sample (= no callback)
			tst.w	mch_status(a6)
			bmi.s	.\@_no_callback

			* Test .ifeq	Callback is enabled
			move.l	a5,-(sp)
			lea.l	mixer(pc),a5
			tst.l	mx_callback_ptr(a5)
			beq.s	.\@_no_callback_enabled
						
			* Set parameters & call the callback
			movem.l	d0/a0,-(sp)
			move.w	mch_channel_id(a6),d0	| Get HW/Mixer channel ID
			move.l	mch_orig_sam_ptr(a6),a0	| A0 = Sample pointer

			* Do the callback
			move.l	mx_callback_ptr(a5),a5
			.ifeq	MIXER_C_DEFS-1
				movem.l	d1/a0/a1,-(sp)
				jsr		(a5)
				movem.l	(sp)+,d1/a0/a1
			.else
				jsr		(a5)
			.endif
			
			* Check .ifeq	a new sample was started
			tst.w	d0
			beq.s	.\@_callback_done
			
			* Set correct new remaining length for new sample			
			.ifeq	mxslength_word-1
				move.w	mch_remaining_length(a6),d3	| D3 = remaining length
			.else
				move.l	mch_remaining_length(a6),d3	| D3 = remaining length
			.endif
			move.l	mch_sample_ptr(a6),\1			| Update pointer
			
.\@_callback_done
			movem.l	(sp)+,d0/a0
.\@_no_callback_enabled
			move.l	(sp)+,a5
.\@_no_callback
		.endif

.\@_write_remaining:
		.ifeq	mxslength_word-1
			move.w	d3,mch_remaining_length(a6)	| Write remaining length
		.else
			move.l	d3,mch_remaining_length(a6)	| Write remaining length
		.endif
		.ifeq	MIXER_ENABLE_PLUGINS-2
			.ifeq	MIXER_TIMING_BARS-1
				move.w	#MIXER_PLUGIN_COLOUR,0xdff180
			.endif
			* Test .ifeq	plugin is active
			tst.l	mch_plugin_ptr(a6)
			beq.s	.\@_write_rem_std
			
			* Skip no-data plugins
			tst.w	mch_plugin_type(a6)
			bpl.s	.\@_write_rem_std
			
			* Check .ifeq	sample position reset
			move.l	\arg,d6
			sub.l	mch_plugin_output_buffer(a6),d6
			beq.s	.\@_write_rem_sam_reset
			
			* Sample is not reset
			add.l	d6,mch_sample_ptr(a6)		| Write sample pointer
			bra.s	.\@_write_rem_done
			
.\@_write_rem_sam_reset:
			move.l	mch_loop_ptr(a6),mch_sample_ptr(a6)	| Write sample pointer
			bra.s	.\@_write_rem_done
			
.\@_write_rem_std:
			move.l	\arg,mch_sample_ptr(a6)		| Write sample pointer
.\@_write_rem_done:
			.ifeq	MIXER_TIMING_BARS-1
				move.w	#MIXER_AUD_COLOUR,0xdff180
			.endif
		.else
			move.l	\arg,mch_sample_ptr(a6)		| Write sample pointer
		.endif

		* Check if remaining length <= smallest remaining length
		.ifeq	mxslength_word-1
			cmp.w	d3,d1 
			bls.s	.\@_next_channel

			move.w	d3,d1
		.else
			cmp.l	d3,d1 
			ble.s	.\@_next_channel

			move.l	d3,d1
		.endif

.\@_next_channel:
		addq.w	#4,d0
				.endm
				
		* Macro: MixUpdateChannel
		* 	.macro	This checks .ifeq	a channel is active and adds it to the channels
		* to be mixed .ifeq	so. Active channels age value is updated.
	.macro	MixUpdateChannel
		tst.w	mch_status(a2)
		beq.s	.\@_done
	
		* Sample is active (one-shot or looping)
		.ifeq	mxslength_word-1
			move.w	mch_remaining_length(a2),d2	| Fetch remaining length
		.else
			move.l	mch_remaining_length(a2),d2	| Fetch remaining length
		.endif
		addq.w	#1,mch_age(a2)				| Update age
		move.l	a2,(a3)+					| Write channel & sample pointers
		
		* Deal with plugins here
		.ifeq	MIXER_ENABLE_PLUGINS-1
			.ifeq	MIXER_TIMING_BARS-1
				move.w	#MIXER_PLUGIN_COLOUR,0xdff180
			.endif
			move.l	mch_plugin_ptr(a2),d7
			bne.s	.\@_run_plugin
			
			move.l	mch_sample_ptr(a2),(a4)+		| No plugin in use
			bra.s	.\@_plugin_done
			
.\@_run_plugin:
			* Run plugin
			move.l	d0,d4
			move.l	d1,d5
			movem.l	a0-a2,-(sp)
			moveq	#0,d1
			tst.b	mch_status+1(a2)
			bne.s	.\@_check_plugin_type

			moveq	#1,d1							| D1 = loop indicator
			move.b	d1,mch_status+1(a2)				| Reset loop for plugins						

.\@_check_plugin_type:			
			tst.w	mch_plugin_type(a2)
			beq.s	.\@_std_plugin
			
			move.l	mch_sample_ptr(a2),a0			| A0 = sample pointer
			bra.s	.\@_nodata_plugin

.\@_std_plugin:
			move.l	mch_plugin_output_buffer(a2),a0	| A0 = sample pointer

.\@_nodata_plugin:		
			move.l	a0,(a4)+
			
			* Set up parameters
			.ifeq	mxslength_word-1
				moveq	#0,d0
				move.w	mixer+mx_buffer_size(pc),d0
				cmp.w	mch_remaining_length(a2),d0
				bls.s	.\@_plugin_len_set
				
				move.w	mch_remaining_length(a2),d0
			.else
				moveq	#0,d0
				move.w	mixer+mx_buffer_size(pc),d0
				cmp.l	mch_remaining_length(a2),d0
				bls.s	.\@_plugin_len_set
				
				move.l	mch_remaining_length(a2),d0
			.endif

.\@_plugin_len_set:
			move.l	mch_plugin_data_ptr(a2),a1		| Fetch data
			move.l	d7,a5
			jsr		(a5)							| Call plugin

			movem.l	(sp)+,a0-a2
			move.l	d4,d0
			move.l	d5,d1
			
.\@_plugin_done:
			.ifeq	MIXER_TIMING_BARS-1
				move.w	#MIXER_CHUPD_COLOUR,0xdff180
			.endif

		.else	
			move.l	mch_sample_ptr(a2),(a4)+
		.endif

		* Update smallest remaining size .ifeq	needed
		.ifeq	mxslength_word-1
			cmp.w	d2,d1
			bls.s	.\@_update_channel

			move.w	d2,d1
		.else
			cmp.l	d2,d1
			ble.s	.\@_update_channel

			move.l	d2,d1
		.endif

.\@_update_channel:
		* Increase channel count
		addq.w	#4,d0

.\@_done:
		* Fetch next channel
		lea.l	mch_SIZEOF(a2),a2
					.endm
					
		* Macro: MixUpdateChannelBufSize
		* 	.macro	This checks .ifeq	a channel is active and adds it to the channels
		* to be mixed .ifeq	so. Active channels age value is updated.
		* This version is for mixing in blocks of the buffer size.
	.macro	MixUpdateChannelBufSize
.\@_chkch_done_dist	SET	MIXER_ENABLE_PLUGINS+MIXER_ENABLE_CALLBACK
		tst.w	mch_status(a2)
		
		.if	.\@_chkch_done_dist>1
			beq		.\@_done
		.else
			beq.s	.\@_done
		.endif
		
		* Sample is active (one-shot or looping)
		.ifeq	mxslength_word-1
			sub.w	d7,mch_remaining_length(a2)	| Update remaining length
			bcc.s	.\@_active_channel

			* Reset remaining length & active status
			clr.b	mch_status+1(a2)
			move.w	mch_loop_length(a2),mch_remaining_length(a2)
			move.l	mch_loop_ptr(a2),mch_sample_ptr(a2)
		.else
			sub.l	d7,mch_remaining_length(a2)	| Update remaining length
			bge.s	.\@_active_channel
			
			* Reset remaining length & active status
			clr.b	mch_status+1(a2)
			move.l	mch_loop_length(a2),mch_remaining_length(a2)
			move.l	mch_loop_ptr(a2),mch_sample_ptr(a2)

		.endif
		.ifeq	MIXER_ENABLE_CALLBACK-1
			* Check .ifeq	this is a looping sample (= no callback)
			move.l	a5,-(sp)
			tst.w	mch_status(a2)
			bmi.s	.\@_no_callback
		
			* Test .ifeq	Callback is enabled
			lea.l	mixer(pc),a5
			tst.l	mx_callback_ptr(a5)
			beq.s	.\@_no_callback
			
			* Set parameters & call the callback
			movem.l	d0/d1/a0,-(sp)
			move.w	mch_channel_id(a2),d0	| Get HW/Mixer channel ID
			move.l	mch_orig_sam_ptr(a2),a0	| A0 = Sample pointer

			* Do the callback
			move.l	mx_callback_ptr(a5),a5
			.ifeq	MIXER_C_DEFS-1
				move.l	a1,-(sp)
				jsr		(a5)
				move.l	(sp)+,a1
			.else
				jsr		(a5)
			.endif
			movem.l	(sp)+,d0/d1/a0

.\@_no_callback
			move.l	(sp)+,a5
		.endif

.\@_active_channel
		move.l	mch_sample_ptr(a2),a6
		addq.w	#1,mch_age(a2)				| Update age
		
		* Deal with plugins here
		.ifeq	MIXER_ENABLE_PLUGINS-1
			.ifeq	MIXER_TIMING_BARS-1
				move.w	#MIXER_PLUGIN_COLOUR,0xdff180
			.endif
			move.l	d7,d6
			move.l	mch_plugin_ptr(a2),d7
			bne.s	.\@_run_plugin
			
			move.l	mch_sample_ptr(a2),(a4)+		| No plugin in use
			bra.s	.\@_plugin_done
			
.\@_run_plugin
			* Run plugin
			movem.l	d0/d1/a0-a2,-(sp)
			moveq	#0,d1
			tst.b	mch_status+1(a2)
			bne.s	.\@_check_plugin_type

			moveq	#1,d1							| D1 = loop indicator
			move.b	d1,mch_status+1(a2)				| Reset loop for plugins						

.\@_check_plugin_type

			tst.w	mch_plugin_type(a2)
			beq.s	.\@_std_plugin
			
			move.l	mch_sample_ptr(a2),a0			| A0 = sample pointer
			bra.s	.\@_nodata_plugin

.\@_std_plugin
			move.l	mch_plugin_output_buffer(a2),a0	| A0 = sample pointer

.\@_nodata_plugin		
			move.l	a0,(a4)+
			
			* Set up parameters
			.ifeq	mxslength_word-1
				moveq	#0,d0
				move.w	mixer+mx_buffer_size(pc),d0
				cmp.w	mch_remaining_length(a2),d0
				bls.s	.\@_plugin_len_set
				
				move.w	mch_remaining_length(a2),d0
			.else
				moveq	#0,d0
				move.w	mixer+mx_buffer_size(pc),d0
				cmp.l	mch_remaining_length(a2),d0
				bls.s	.\@_plugin_len_set
				
				move.l	mch_remaining_length(a2),d0
			.endif

.\@_plugin_len_set
			move.l	mch_plugin_data_ptr(a2),a1		| Fetch data
			move.l	d7,a5
			jsr		(a5)							| Call plugin
		
			movem.l	(sp)+,d0/d1/a0-a2
			
.\@_plugin_done
			move.l	d6,d7
			.ifeq	MIXER_TIMING_BARS-1
				move.w	#MIXER_CHUPD_COLOUR,0xdff180
			.endif

		.else	
			move.l	mch_sample_ptr(a2),(a4)+
		.endif

		.ifeq	mxslength_word-1
			add.w	d7,a6
		.else
			add.l	d7,a6
		.endif
		move.l	a6,mch_sample_ptr(a2)		| Update sample pointer
		
.\@_update_channel
		* Increase channel count
		addq.w	#4,d0
		
.\@_done
		* Fetch next channel
		lea.l	mch_SIZEOF(a2),a2
						.endm

		* Macro: MixUpdateChannels
		* 	.macro	This checks .ifeq	all channels are active and adds them to the 
		* channels to be mixed .ifeq	so. Active channels age value is updated.
	.macro	MixUpdateChannels
		* Fetch pointers & buffer size
		lea.l	mxe_channels(a1),a2
		.ifeq	MIXER_68020
			.ifeq	MIXER_SIZEXBUF
				lea.l	mxe_active_channels(a1),a3
			.endif
		.else
			lea.l	mxe_active_channels(a1),a3
		.endif
		lea.l	mxe_pointers(a1),a4
		
		* Clear channel counter & set minimum length/buffer size
		moveq	#0,d0
		move.w	mixer+mx_buffer_size(pc),d1
		
		* Set maximum length
		.ifeq	mxslength_word-1
			move.w	d1,d7
		.else
			ext.l	d1
			move.l	d1,d7
		.endif
		
		.ifeq	MIXER_SIZEXBUF
			.ifeq	MIXER_SINGLE-1
				move.l	d7,d6					| Store D7
			.else
				move.l	d7,-(sp)
			.endif
		.endif
		
		* Update each channel
		.ifeq	MIXER_68020-1
			moveq	#mixer_sw_channels-1,d3

.mix_upd_ch_lp
			MixUpdateChannel
			dbra	d3,.mix_upd_ch_lp
		.else
			.rept mixer_sw_channels
				.ifeq	MIXER_SIZEXBUF-1
					MixUpdateChannelBufSize
				.else
					MixUpdateChannel
				.endif
			.endr
		.endif
		
		.ifeq	MIXER_SIZEXBUF
			.ifeq	MIXER_SINGLE-1
				move.l	d6,d7					| Restore D7
			.else
				move.l	(sp)+,d7
			.endif
		.endif
					.endm
					
		* Macro: MixChannels
		* 	.macro	This mixes all active channels
	.macro	MixChannels
		* Select number of channels to mix
		jmp		.jmp_table(pc,d0.w)
.jmp_table:
		jmp		.mix_silence(pc)			| 0
		jmp		.mix_copy_only(pc)			| 1
		.if	mixer_sw_channels>1
			jmp		.mix_2_channels(pc)		| etc
		.endif
		.if	mixer_sw_channels>2
			jmp		.mix_3_channels(pc)
		.endif
		.if	mixer_sw_channels>3
			jmp		.mix_4_channels(pc)
		.endif
		
.mix_silence:
		.ifeq	MIXER_SINGLE-1
			lea.l	mxcustombase,a6
			lea.l	mxsinglechan(a6),a6
			move.l	mixer+mx_empty_buffer(pc),ac_ptr(a6)
			move.w	mixer+mx_hw_period(pc),ac_per(a6)
		.else
			lea.l	mxcustombase,a6
			move.l	mixer+mx_empty_buffer(pc),ac_ptr(a6,d6.w)
			move.w	mixer+mx_hw_period(pc),ac_per(a6,d6.w)
			.ifeq	MIXER_MULTI_PAIRED-1
				move.w	#0,mxe_active(a1)
			.endif
		.endif
		bra		.mix_done

.mix_copy_only:
		.ifeq	MIXER_MULTI_PAIRED-1
			move.w	#1,mxe_active(a1)
		.endif
			
		* Fetch source pointers
		move.l	mxe_pointers(a1),a2

.mix_1ch_start:
		* Mix the channels
		.ifeq	MIXER_SIZEXBUF-1
			MixBlockBufSize 1
		.else
			.ifeq	MIXER_HQ_MODE-1
				MixLoopHQ 1
				MixCalcRem4 1
			.else
				MixJump32 1
				MixBlock32 1
				MixChkRem32 1
				MixJump4 1
				MixBlock4 1
				MixCalcRem4 1
			.endif
		.endif
	
	.if	mixer_sw_channels>1
.mix_2_channels:
		.ifeq	MIXER_MULTI_PAIRED-1
			move.w	#1,mxe_active(a1)
		.endif

		* Fetch source pointers
		movem.l	mxe_pointers(a1),a2/a3
		
.mix_2ch_start:
		* Mix the channels
		.ifeq	MIXER_SIZEXBUF-1
			MixBlockBufSize 2
		.else
			.ifeq	MIXER_HQ_MODE-1
				MixLoopHQ 2
				MixCalcRem4 2
			.else
				MixJump32 2
				MixBlock32 2
				MixChkRem32 2
				MixJump4 2
				MixBlock4 2
				MixCalcRem4 2
			.endif
		.endif
	.endif
		
	.if	mixer_sw_channels>2
.mix_3_channels:
		.ifeq	MIXER_MULTI_PAIRED-1
			move.w	#1,mxe_active(a1)
		.endif

		* Fetch source pointers
		movem.l	mxe_pointers(a1),a2/a3/a4
		
.mix_3ch_start:
		* Mix the channels
		.ifeq	MIXER_SIZEXBUF-1
			MixBlockBufSize 3
		.else
			.ifeq	MIXER_HQ_MODE-1
				MixLoopHQ 3
				MixCalcRem4 3
			.else
				MixJump32 3
				MixBlock32 3
				MixChkRem32 3
				MixJump4 3
				MixBlock4 3
				MixCalcRem4 3
			.endif
		.endif
	.endif
		
	.if	mixer_sw_channels>3
.mix_4_channels:
		.ifeq	MIXER_MULTI_PAIRED-1
			move.w	#1,mxe_active(a1)
		.endif

		* Fetch source pointers
		movem.l	mxe_pointers(a1),a2/a3/a4/a5
		
.mix_4ch_start:
		* Mix the channels
		.ifeq	MIXER_SIZEXBUF-1
			MixBlockBufSize 4
		.else
			.ifeq	MIXER_HQ_MODE-1
				MixLoopHQ 4
				MixCalcRem4 4
			.else
				MixJump32 4
				MixBlock32 4
				MixChkRem32 4
				MixJump4 4
				MixBlock4 4
				MixCalcRem4 4
			.endif
		.endif
	.endif

.mix_done:
		* End of mixing
				.endm
				
		* Macro: MixChannels020
		* 	.macro	This mixes all channels (68020+ optimised version)
	.macro	MixChannels020
		* Select number of channels to mix
		jmp		.jmp_table(pc,d0.w)

.jmp_table:
		jmp		mix_silence(pc)			| 0
		jmp		mix_copy_only(pc)			| 1
		.if	mixer_sw_channels>1
			jmp		.mix_2_channels(pc)		| etc
		.endif
		.if	mixer_sw_channels>2
			jmp		.mix_3_channels(pc)
		.endif
		.if	mixer_sw_channels>3
			jmp		.mix_4_channels(pc)
		.endif
		
mix_silence:
		.ifeq	MIXER_SINGLE-1
			lea.l	mxcustombase,a6
			lea.l	mxsinglechan(a6),a6
			move.l	mixer+mx_empty_buffer(pc),ac_ptr(a6)
			move.w	mixer+mx_hw_period(pc),ac_per(a6)
		.else
			lea.l	mxcustombase,a6
			move.l	mixer+mx_empty_buffer(pc),ac_ptr(a6,d6.w)
			move.w	mixer+mx_hw_period(pc),ac_per(a6,d6.w)
			.ifeq	MIXER_MULTI_PAIRED-1
				move.w	#0,mxe_active(a1)
			.endif
		.endif
		bra		mix_done

mix_copy_only:
		.ifeq	MIXER_MULTI_PAIRED-1
			move.w	#1,mxe_active(a1)
		.endif
		
		* Setup
		move.l	mxe_pointers(a1),a2			| Fetch pointer

mix_1ch_start:	
		* Mix channels
		.ifeq	MIXER_HQ_MODE-1
			MixLoopHQ 1
		.else
			MixLoop020 1
		.endif
		MixCalcRem4 1

	.if	mixer_sw_channels>1
.mix_2_channels:
		.ifeq	MIXER_MULTI_PAIRED-1
			move.w	#1,mxe_active(a1)
		.endif
		
		* Setup
		movem.l	mxe_pointers(a1),a2/a3		| Fetch pointers

.mix_2ch_start:	
		* Mix channels
		.ifeq	MIXER_HQ_MODE-1
			MixLoopHQ 2
		.else
			MixLoop020 2
		.endif	
		MixCalcRem4 2
	.endif
		
	.if	mixer_sw_channels>2
.mix_3_channels:
		.ifeq	MIXER_MULTI_PAIRED-1
			move.w	#1,mxe_active(a1)
		.endif
		
		* Setup
		movem.l	mxe_pointers(a1),a2/a3/a4	| Fetch pointers

.mix_3ch_start		
		* Mix channels
		.ifeq	MIXER_HQ_MODE-1
			MixLoopHQ 3
		.else
			MixLoop020 3
		.endif
		MixCalcRem4 3
	.endif
	
	.if	mixer_sw_channels>3		
.mix_4_channels
		.ifeq	MIXER_MULTI_PAIRED-1
			move.w	#1,mxe_active(a1)
		.endif

		* Setup
		movem.l	mxe_pointers(a1),a2/a3/a4/a5| Fetch pointers

.mix_4ch_start
		* Mix channels
		.ifeq	MIXER_HQ_MODE-1
			MixLoopHQ 4
		.else
			MixLoop020 4
		.endif		
		MixCalcRem4 4

.mix_4ch_done
	.endif

.mix_done
		* End of mixing
				.endm

		* Macro: MixDeferredActionInnerLoop
		* 	.macro	This is the inner loop for dealing with deferred plugin
		* actions
	.macro	MixDeferredActionInnerLoop
		move.l	mch_plugin_deferred_ptr(a2),d3
		tst.l	d3
		beq.s	.\@_end_deferred_lp
			
		* Set up for deferred call
		move.l	mch_plugin_output_buffer(a2),a0
		move.l	mch_plugin_data_ptr(a2),a1
		move.l	d3,a3
		.ifeq	MIXER_C_DEFS-1
			movem.l	d0/d1/a0/a1,-(sp)
			jsr		(a3)
			movem.l	(sp)+,d0/d1/a0/a1
		.else
			jsr		(a3)
		.endif
			
.\@_end_deferred_lp:
		clr.l	mch_plugin_deferred_ptr(a2)
		lea.l	mch_SIZEOF(a2),a2
							.endm

		* Macro: MixDeferredActions
		* 	.macro	This deals with deferred plugin actions
	.macro	MixDeferredActions			
			.ifeq	MIXER_TIMING_BARS-1
				move.w	#MIXER_PLUGIN_COLOUR,0xdff180
			.endif

			lea.l	mxe_channels(a1),a2
			.ifeq	MIXER_68020-1
				moveq	#mixer_sw_channels-1,d7
.deferred_lp:
				MixDeferredActionInnerLoop
				dbra	d7,.deferred_lp
			.else
				.REPT mixer_sw_channels
					MixDeferredActionInnerLoop
				.ENDR
			.endif
					.endm

*-----------------------------------------------------------------------------
* Interrupt handler / mixing routines
*-----------------------------------------------------------------------------
		* Routine: MixerIRQHandler
		* This routine is the interrupt handler for the mixer. It reacts to
		* audio interrupts, mixes the mixer channels and plays back the audio.
		*
		* The mixing routines use double buffering, where one buffer is played
		* back while the next buffer is being mixed.
		*
		* Note: for performance reasons, the code to handle various mixer types 
		*       has been implemented 	.macro	ass. The handler merely combines 
		*       these into the correct variant as set up in mixer_config.i.
MixerIRQHandler:
		* Interrupt handler start
		.ifeq	MIXER_SINGLE-1
			MixSingIHstart
		.else
			MixMultIHstart
		.endif
		
		* Update & mix channels
		MixUpdateChannels

		.ifeq	MIXER_TIMING_BARS-1
			move.w	#MIXER_AUD_COLOUR,0xdff180
		.endif
		
		.ifeq	MIXER_68020-1
			MixChannels020
		.else
			MixChannels
		.endif
		
		* deferred plugin actions
		.ifeq	MIXER_ENABLE_PLUGINS-1
			MixDeferredActions
		.endif
		
		* Interrupt handler end
		.ifeq	MIXER_SINGLE-1
			MixSingIHend
		.else
			MixMultIHend
		.endif

*-----------------------------------------------------------------------------
* Support routines
*-----------------------------------------------------------------------------

		* Routine: MixerGetBufferSize
		* This routine returns the value of mixer_buffer_size, the required
		* size of the Chip RAM buffer that needs to be allocated and passed to
		* MixerSetup().
		*
		* It's primary purpose is to give C programs a way to get this value
		* without needing access to mixer.i
		*
		* Returns
		* D0 - value of mixer_buffer_size
MixerGetBufferSize:
		move.l	#mixer_buffer_size,d0
		rts
		
		* Routine: MixerGetChannelBufferSize
		* This routine returns the value of the internal mixer buffer size.
		*
		* It's primary purpose is to give plugins a way to get this value
		* without needing access to the mixer structure.
		*
		* Returns
		* D0 - value of mixer_buffer_size
MixerGetChannelBufferSize:
		move.l	a0,-(sp)					| Stack
		lea.l	mixer(pc),a0
		move.w	mx_buffer_size(a2),d0
		move.l	(sp)+,a0					| Stack
		rts

		* Routine: MixerGetPluginsBufferSize
		* This routine returns the value of mixer_plugin_buffer_size, the 
		* required size of the RAM buffer that needs to be allocated and 
		* passed to MixerSetup() .ifeq	MIXER_ENABLE_PLUGINS is set to 1.
MixerGetPluginsBufferSize:
		.ifeq	MIXER_ENABLE_PLUGINS-1
			move.l	#mixer_plugin_buffer_size,d0
		.endif
		rts
		
		* Routine: MixerGetSampleMinSize
		* This routine returns the miminum sample size. This is the minimum
		* sample size the mixer can play back correctly. Samples must always
		* be a multiple of this value in length.
		*
		* Normally this value is 4, but optimisation options in mixer_config.i
		* can increase this.
		*
		* Note: MixerSetup() must have been called prior to calling this
		*       routine.
		*
		* Returns
		* D0 - minimum sample size
MixerGetSampleMinSize:
		move.l	a0,-(sp)					| Stack
		lea.l	mixer(pc),a0
		
		* Preload PAL value
		moveq	#0,d0
		move.l	#mixer_PAL_multiple,d0
		tst.w	mx_vidsys(a0)
		beq.s	.done

		* NTSC value
		move.l	#mixer_NTSC_multiple,d0

.done:
		move.l	(sp)+,a0					| Stack
		rts
		
		* Routine: MixerGetTotalChannelCount
		* This routine returns the total number of channels (= 
		* mixer_sw_channels * mixer_output_count) the mixer supports.
		*
		* Returns
		* D0 - total channel count
MixerGetTotalChannelCount:
		moveq	#mixer_total_channels,d0
		rts
		
		* Routine: MixerGetChannelStatus
		* This routine returns whether or not the hardware/mixer channel given
		* in D0 is in use. 
		*
		* D0 - Hardware channel/mixer channel mask (f.ex. DMAF_AUD0|MIX_CH1)
		*      Note: .ifeq	MIXER_SINGLE-1, hardware channel selection is ignored.
		*
		* Returns
		* D0 - either MIX_CH_FREE .ifeq	the given channel is unused, or 
		*      MIX_CH_BUSY .ifeq	the channel is in use.
MixerGetChannelStatus:
		movem.l	d2/d4/a1,-(sp)				| Stack
		
		* Fetch the correct mixer entry
		bsr		MixerFetchEntry
		
		* Clear output
		moveq	#0,d0
		
		.ifeq	MIXER_SINGLE-1
			* Set HW channel to correct channel for single mixing
			moveq	#mxsingledma,d2
			and.w	#0xf0,d0
			or.w	d2,d0
		.endif
		
		* Jump to selected channel
		move.w	d0,d4
		asr.w	#4,d4
		add.w	d4,d4
		add.w	d4,d4
		jmp		0f(pc,d4.w)

		* Jump table
		* The empty space included in the table is required for the 
		* conversion between channel bit and channel number.
0:
		nop
		nop
		jmp	0f(pc)
		jmp	1f(pc)
		.long	0
		jmp	2f(pc)
		.long	0,0,0
			
3:	lea.l	mch_SIZEOF(a1),a1
2:	lea.l	mch_SIZEOF(a1),a1
1:	lea.l	mch_SIZEOF(a1),a1
0:	

		* Test .ifeq	given channel is in use
		moveq	#MIX_CH_FREE,d0
		tst.w	mch_status(a1)
		beq.s	0f
		
		moveq	#MIX_CH_BUSY,d0
		
0:
		movem.l	(sp)+,d2/d4/a1				| Stack
		rts

		* Routine: MixerSetPluginDeferredPtr
		* This routine sets the pointer for the deferred plugin action to take
		* on the current channel.
		*
		* A0 - Pointer to routine to use for the deferred action
		* A2 - Pointer to MXChannel structure
MixerSetPluginDeferredPtr:
		.ifeq	MIXER_ENABLE_PLUGINS-1
			move.l	a0,mch_plugin_deferred_ptr(a2)
		.endif
		rts

		* Routine: MixerEnableCallback
		* This routine enables the callback function. Callback functions take
		* two parameters: The HW channel/mixer channel combination in D0 and 
		* the pointer to the start of the sample that just finished playing in
		* A0.
		*
		* Callback functions return either 0 in D0 .ifeq	no new sample has 
		* been started by the callback, or a non-zero value .ifeq	a new sample
		* was started by the callback on the same channel.
		*
		* A0 - Pointer to callback function.
MixerEnableCallback:
		.ifeq	MIXER_ENABLE_CALLBACK-1
			move.l	a1,-(sp)			| stack
			
			lea.l	mixer(pc),a1
			move.l	a0,mx_callback_ptr(a1)
			
			move.l	(sp)+,a1			| Stack
		.endif
		rts

		* Routine: MixerDisableCallback
		* This routine disables the callback function.
MixerDisableCallback:
		.ifeq	MIXER_ENABLE_CALLBACK-1
			move.l	a0,-(sp)			| Stack
			
			* Reset callback pointer
			lea.l	mixer(pc),a0
			clr.l	mx_callback_ptr(a0)
			
			move.l	(sp)+,a0			| Stack
		.endif
		rts

		* Routine: MixerPlaySilence
		* This routine plays the silent (empty) buffer via Paula.
		*
		* D1 - Hardware channel to play silence on
MixerPlaySilence:
		movem.l	d0/d1/a0/a6,-(sp)			| Stack

		* Fetch audio channel
		lea.l	mxcustombase,a6
		
		* Get empty buffer & buffer size in words
		lea.l	mixer(pc),a0
		
		* Set audio register values
		move.l	mx_empty_buffer(a0),ac_ptr(a6,d1.w)
		move.w	mx_buffer_size_w(a0),ac_len(a6,d1.w)
		move.w	mx_hw_period(a0),ac_per(a6,d1.w)
		move.w	mx_volume(a0),ac_vol(a6,d1.w)

		* Calculate audio bit to set
		sub.w	#aud,d1
		asr.w	#4,d1
		move.w	#DMAF_SETCLR,d0
		bset	d1,d0
		
		* Activate audio DMA
		move.w	d0,dmacon(a6)

		movem.l	(sp)+,d0/d1/a0/a6			| Stack
		rts

		* Routine: MixerClearBuffer
		* This routine clears the given buffer to zero.
		* Note: this routine is not speed optimized.
		*
		* A0 - Pointer to buffer to clear
MixerClearBuffer:
		movem.l	d0/d7/a0/a1,-(sp)			| Stack
		
		* Fetch buffer size in longwords
		lea.l	mixer(pc),a1
		move.w	mx_buffer_size(a1),d7
		
		* Prepare for loop
		moveq	#0,d0
		asr.w	#2,d7
		subq.w	#1,d7
		
		* Loop over longwords in the buffer
0:		
		move.l	d0,(a0)+
		dbra	d7,0b
		
		movem.l	(sp)+,d0/d7/a0/a1			| Stack
		rts
		
		* Routine: MixerClearPluginData
		* This routine clears the given plugin data structure to zero.
		* Note: this routine is not speed optimised
		*
		* D0 - length of structure
		* A0 - Pointer to structure to clear
MixerClearPluginData:
		movem.l	d0/d1/a0,-(sp)				| Stack
		
		* Prepare for loop
		moveq	#0,d1
		asr.w	#1,d0						| Size is in words
		subq.w	#1,d0
		
		* Loop over words in the structure
0:
		move.w	d1,(a0)+
		dbra	d0,0b
		
		movem.l	(sp)+,d0/d1/a0				| Stack
		rts
		
		* Routine: MixerCalcTicks
		* This routine calculates the average tick time over the rolling
		* 128 entry buffer. It also converts the recorded CIA timer values to
		* to CIA ticks (0xffff-CIA timer value = CIA ticks).
		*
		* Note: only functions .ifeq	MIXER_CIA_TIMER is set to 1
		* Note: values only accurate .ifeq	mixer has been running and playing 
		*       back sample data at least 128 frames.
MixerCalcTicks:
		.ifeq	MIXER_CIA_TIMER-1
			movem.l	d0/d1/d7/a0,-(sp)		| Stack

			* Fetch the buffer
			lea.l	mixer_ticks_storage(pc),a0
	
			* Set up for loop
			moveq	#0,d0
			moveq	#128-1,d7
			
			* Loop over all entries
.lp:			moveq	#0,d1
			move.w	(a0)+,d1
			add.l	d1,d0
			dbra	d7,.lp
			
			* Calculate average
			divu.w	#128,d0
			lea.l	mixer_ticks_average(pc),a0
			move.w	d0,(a0)
			
			* Calculate CIA ticks from CIA timer values recorded
			* This is needed because the CIA timer values run from 0xffff to 0,
			* so the values recorded are inverted from the actual number of
			* ticks that have elapsed.
			lea.l	mixer_ticks_last(pc),a0
			moveq	#4-1,d7
	
			* Loop over the results
.lp2:		moveq	#-1,d1
			move.w	(a0),d0
			sub.w	d0,d1
			move.w	d1,(a0)+
			dbra	d7,.lp2
			
			movem.l	(sp)+,d0/d1/d7/a0		| Stack
		.endif
		rts
		
		* Routine: MixerResetCounter
		* This routine sets the mixer interrupt counter to 0
		*
		* Note: only functions .ifeq	MIXER_COUNTER is set to 1
MixerResetCounter:
		.ifeq	MIXER_COUNTER-1
			move.l	a0,-(sp)				| Stack
		
			lea.l	mixer(pc),a0
			clr.w	mx_counter(a0)
		
			move.l	(sp)+,a0				| Stack
		.endif
		rts

		* Routine: MixerGetCounter
		* This routine gets the current value of the mixer interrupt counter.
		*
		* Note: only functions .ifeq	MIXER_COUNTER is set to 1
		*
		* Returns
		* D0 - value of the mixer counter (word)
MixerGetCounter:
		.ifeq	MIXER_COUNTER-1
			move.l	a0,-(sp)					| Stack
			
			lea.l	mixer(pc),a0
			move.w	mx_counter(a0),d0
			
			move.l	(sp)+,a0					| Stack
		.endif
		rts

* Mixer data
		.align  4
mixer:
					.skip	mx_SIZEOF
		.ifeq	MIXER_68020-1
			.align  4
		.endif
mixer_fx_struct:
			.skip	mfx_SIZEOF
		.ifeq	MIXER_68020-1
			.align  4
		.endif
mixer_stored_vbr:		.long	0
mixer_stored_handler:	.long	0
mixer_stored_intena:		.short	0
		.ifeq	MIXER_CIA_TIMER-1
mixer_stored_cia:		.short	0
mixer_ticks_last:		.short	0
mixer_ticks_best:		.short	0
mixer_ticks_worst:		.short	0xffff
mixer_ticks_average:		.short	0
mixer_ticks_storage_off:	.short	0
mixer_ticks_storage:		.skip	128*2
		.endif
		
		.ifeq	MIXER_C_DEFS-1
* C style routine aliases
_MixerGetBufferSize			=	MixerGetBufferSize
_MixerSetup					= MixerSetup
_MixerInstallHandler		= MixerInstallHandler
_MixerRemoveHandler			= MixerRemoveHandler
_MixerStart					= MixerStart
_MixerStop					= MixerStop
_MixerVolume				= MixerVolume
_MixerPlayFX				= MixerPlayFX
_MixerPlayChannelFX			= MixerPlayChannelFX
_MixerStopFX				= MixerStopFX
_MixerPlaySample			= MixerPlaySample
_MixerPlayChannelSample		= MixerPlayChannelSample
_MixerGetSampleMinSize		= MixerGetSampleMinSize
_MixerGetChannelStatus		=	MixerGetChannelStatus
_MixerEnableCallback		= MixerEnableCallback
_MixerDisableCallback		=	MixerDisableCallback
_MixerGetPluginsBufferSize	= MixerGetPluginsBufferSize
_MixerGetTotalChannelCount	= MixerGetTotalChannelCount
_MixerSetPluginDeferredPtr	= MixerSetPluginDeferredPtr
_MixerGetChannelBufferSize	= MixerGetChannelBufferSize
_MixerResetCounter			=	MixerResetCounter
_MixerGetCounter			=	MixerGetCounter



		.endif
		
	.endif
* End of File
